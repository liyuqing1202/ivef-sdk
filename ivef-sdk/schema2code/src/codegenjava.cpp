/*
 *  codegenqt.cpp
 *
 *  schema2code is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  schema2code is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Created by Lukassen on 11/06/08.
 *  Copyright 2008
 *
 */

#include <cstdlib>

#include "codegenjava.h"

CodeGenJava::CodeGenJava()
        : CodeGen() {
    m_prefix = "";
}

void CodeGenJava::setObjects(QVector<XSDObject*>objects) {
    m_objects = objects;
}

void CodeGenJava::setOutputDir(QString outDir) {
    m_outDir = outDir;
}

QString CodeGenJava::sizeEvaluatorForType (QString type, QString varName) {
    if (type == "xs:string")
        return varName + ".length()";
    else if (type == "xs:hexBinary") // or should it by a QByteArray?
        return varName + ".size()";
    else
        return varName;
}

QString CodeGenJava::localType(QString type) {
    if (type == "xs:string")
        return "String";
    else if (type == "xs:boolean")
        return "boolean";
    else if (type == "xs:integer")
        return "int";
    else if (type == "xs:dateTime")
        return "Date";
    else if (type == "xs:hexBinary")
        return "String";
    else if (type == "unknown") {
        std::cout << "WARNING unknown type found:" << type.toLatin1().data() <<  ", defaulting to String" << std::endl;
        return "String";
    } else if (type == "xs:decimal") // double
        return "double";
    else
        return type;
}

bool CodeGenJava::knownType(QString type) {
    if (type == "xs:string")
        return true;
    else if (type == "xs:boolean")
        return true;
    else if (type == "xs:integer")
        return true;
    else if (type == "xs:dateTime")
        return true;
    else if (type == "xs:hexBinary")
        return true;
    else if (type == "unknown")
        return true;
    else if (type == "xs:decimal") // double
        return true;
    else
        return false;
}

QString CodeGenJava::methodName(QString name) {

    // handle special methods
    if (name == "Class")
        name = m_prefix + name;

    return name.replace(0, 1, name.left(1).toUpper());
}

QString CodeGenJava::className(QString name) {
    return /*m_prefix +*/ name.replace(0, 1, name.left(1).toUpper());
}

QString CodeGenJava::fileBaseName(QString name) {
    return className(name);
}

QString CodeGenJava::variableName(QString name) {

    if (name.mid(1,1).toUpper() == name.mid(1,1)) { // if second char is uppercase
        return "m_" + name;
    } else {
        return "m_" + name.replace(0, 1, name.left(1).toLower());
    }
}

QString CodeGenJava::longestCommonPrefix(QStringList strings) {

    if (strings.size() < 1) {
        return ""; // not good
    }
    if (strings.size() < 2) {
        return strings.at(0); // all in common with myself
    }
    // take the first item as initial prefix
    QString prefix = strings.at(0);
    int length = prefix.length();

    // compare the current prefix with the prefix of the same length of the other items
    foreach(QString item, strings) {
        // check if there is a match; if not, decrease the prefix by one character at a time
        while ((length > 0) && (item.left(length) != prefix)) {
            length--;
            prefix = prefix.left(length);
        }
    }

    // if no common prefix, return value will be ""
    return prefix;
}

QString CodeGenJava::writeHeader(QString fileName) {

    QString header;
    header.append( "/* \n" );
    header.append( " *  " + fileName + "\n" );
    header.append( " *\n" );
    header.append( " *  " + fileName + " is free software: you can redistribute it and/or modify\n" );
    header.append( " *  it under the terms of the GNU Lesser General Public License as published by\n" );
    header.append( " *  the Free Software Foundation, either version 3 of the License, or\n" );
    header.append( " *  (at your option) any later version.\n" );
    header.append( " *\n" );
    header.append( " *  Foobar is distributed in the hope that it will be useful,\n" );
    header.append( " *  but WITHOUT ANY WARRANTY ); without even the implied warranty of\n" );
    header.append( " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" );
    header.append( " *  GNU General Public License for more details.\n" );
    header.append( " *\n" );
    header.append( " **********************************************************************************\n" );
    header.append( " *  WARNING: THIS CODE WAS GENERATED DO NOT MODIFY, CHANGE THE XSD INSTEAD\n" );
    header.append( " *  Generated by schema2code on "+  QDateTime::currentDateTime().toString() + ".\n" );
    header.append( " **********************************************************************************\n" );
    header.append( " *  Copyright 2010\n" );
    header.append( " *\n" );
    header.append( " */\n\n" );

    return header;
}

void CodeGenJava::go() {

    // first analyse the objects if they are embedded objects
    // for all objects that could accept such an object
    QString nameSpace = "none";
    bool useNameSpace = false;
    for (int i=0; i < m_objects.size(); i++) {
        // for all objects
        XSDObject *obj1 = m_objects.at(i);
        obj1->setSimpleElement(false); // assume not a simple element

        // find if there is another object that refers to the obj
        for (int h=0; h < m_objects.size(); h++) {

            XSDObject *obj2 = m_objects.at(h);

            // refers means obj2 has an attribute of type obj1
            for (int j=0; j < obj2->attributes().size(); j++) {
                XSDAttribute *attr = obj2->attributes().at(j);
                QString objType = attr->type();

                // if obj1 is a simple element of obj2 we don't need to generate a class for it
                if (attr->isSimpleElement() && attr->name() == obj1->name()) {
                    //std::cout << QString("Should i ignore attr: %1 for obj2 %2 obj1 %3?").arg(attr->name(), obj2->name(), obj1->name()).toLatin1().data() << std::endl;
                    obj1->setSimpleElement(true);
                    std::cout << QString("marking class: %1 for skip").arg(className(obj1->name())).toLatin1().data() << std::endl;
                }

                if (objType == obj1->name()) {
                    obj1->setEmbedded();    // obj1 is embedded in obj2
                }
            }
        }

        // find out what our namespace is
        if (obj1->name() == "Schema") {
            for (int j=0; j < obj1->fixedValues().size(); j++) {
                QString attrName = obj1->fixedValues().keys().at(j);
                if (attrName == "targetNamespace") {
                    nameSpace = obj1->fixedValues().values().at(j);
                    std::cout << "Using namespace: " << nameSpace.toLatin1().data() << std::endl;
                    useNameSpace = true;
                }
            }
        }
    }

    QString package = "schema2code";
    if (m_prefix != "") {
        package =  m_prefix.toLower();
    } else {
        m_prefix = "XSD";
    }

    for (int i=0; i < m_objects.size(); i++) {
        // get a class
        XSDObject *obj = m_objects.at(i);

        // get some vars we frequently use
        QString name = obj->name();
        QString upperName = name.toUpper();
        QString lowerName = name.toLower();
        QVector<XSDAttribute*>attributes = obj->attributes();
        QMap<QString, QString>fixedValues = obj->fixedValues();

        // check for simple elements
        if (obj->isSimpleElement()) {
            std::cout << QString("skipping class: %1").arg(className(name)).toLatin1().data() << std::endl;
            continue;
        }

        // report
        std::cout << QString("creating class: %1").arg(className(name)).toLatin1().data() << std::endl;

        // and the class file
        QString baseName = m_outDir + "/" + package + "/" + fileBaseName(name);
        QDir outDir( m_outDir );
        if ( !outDir.exists() )
        {
            std::cerr << QString("output dir does not exist: %1").arg(m_outDir).toLatin1().data() << std::endl;
            std::exit(1);
        }
        if ( !outDir.exists( package ) &&
             !outDir.mkdir( package ) )
        {
            std::cerr << QString("can not create output dir: %1/%2").arg(outDir.path(),package).toLatin1().data() << std::endl;
            std::exit(2);
        }
        QFile classFile(baseName + ".java");
        if (!classFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            std::cerr << QString("cannot create file: %1").arg(classFile.fileName()).toLatin1().data() << std::endl;
            std::exit(3);
        }
        QTextStream classFileOut(&classFile);

        //-----------------------------------------------------------------------------------------------
        // generate the declaration
        //-----------------------------------------------------------------------------------------------
        classFileOut << writeHeader( className(name) );

        classFileOut << "package " << package << ";\n\n";

        classFileOut << "import java.util.*;\n";
        classFileOut << "import java.text.DecimalFormat;\n";
        classFileOut << "import java.text.DateFormat;\n";
        classFileOut << "import java.text.SimpleDateFormat;\n\n";


        // include dependend files
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            if (!knownType(attr->type())) {
                classFileOut << "import " << package << "." << fileBaseName(attr->type()) << ";\n";
            }
        }

        // define the class
        QString baseClass = "";
        if (obj->hasBaseClass()) {
            baseClass = " extends " + obj->baseClass();
        }
        classFileOut << "\npublic class " << className(name) << baseClass << " { \n\n";

        // variables section
        // all attributes
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString type = localType(attr->type()); // convert to java types
            // definition
            if (attr->isScalar()) { // there more then one
                classFileOut << "    private Vector<" << className(attr->name()) << "> " << variableName(attr->name()) << "s = new Vector<" << className(attr->name()) << ">();\n";
            } else {
                classFileOut << "    private " << type << " " << variableName(attr->name()) << "; // default value is uninitialized\n";
            }

            //if (!attr->required() || obj->isMerged()) { // issue 21
            classFileOut << "    private boolean " << variableName(attr->name()) << "Present;\n";
            //}
        }

        //-----------------------------------------------------------------------------------------------
        // create the implementation
        //-----------------------------------------------------------------------------------------------

        // constructor
        classFileOut << "\n    public " << className(name) << "() {\n\n";
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString niceVarName  = attr->name().replace(0, 1, attr->name().left(1).toLower());
            if (attr->isFixed()) {
                classFileOut << "        " << variableName(attr->name()) << " = \"" << attr->fixed() << "\";\n";
                classFileOut << "        " << variableName(attr->name()) << "Present = true;\n"; // issue 21
            } else {
                classFileOut << "        " << variableName(attr->name()) << "Present = false;\n"; // issue 21
            }
        }
        classFileOut << "    }\n\n";

        // copy constructor
        classFileOut << "    public " << className(name) << "(" << className(name) << " val) {\n\n";
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString type = localType(attr->type()); // convert to java types

            //if ((!attr->required() || obj->isMerged()) && !attr->unbounded()) { // issue 21
            //    classFileOut << "        " << variableName(attr->name()) << "Present = val.has" << methodName(attr->name()) << "();\n";
            //}
            if (attr->isScalar()) { // there more then one
                classFileOut << "        for(int i=0; i < val.countOf" << methodName(attr->name()) << "s(); i++ ) {\n";
                classFileOut << "            " << variableName(attr->name()) << "s.add( val.get" << methodName(attr->name()) << "At(i) );\n";
                classFileOut << "        }\n";
            } else {
                classFileOut << "        " << variableName(attr->name()) << " = val.get" << methodName(attr->name()) << "();\n";
                classFileOut << "        if (val != null) {\n";
                classFileOut << "            " << variableName(attr->name()) << "Present = true;\n"; // issue 21
                classFileOut << "        }\n";
            }
        }
        classFileOut << "    }\n\n";

        // methods for attributes
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString type = localType(attr->type()); // convert to java types
            if (attr->isScalar()) { // there more then one
                // remover
                classFileOut << "    public boolean " << "remove" << methodName(attr->name()) << "(" << type << " val) {\n";

                if (attr->hasMinLength()) {
                    classFileOut << "          if ("<< variableName(attr->name()) << "s.size() <= " << attr->minLength() << ") {\n";
                    classFileOut << "              return false; // scalar already at minOccurs\n";
                    classFileOut << "          }\n";
                }
                classFileOut << "\n        " << variableName(attr->name()) << "s.remove(val);\n";
                classFileOut << "          return true;\n";
                classFileOut << "    }\n\n";
                // setter
                classFileOut << "    public boolean " << "add" << methodName(attr->name()) << "(" << type << " val) {\n";

                if (attr->hasMaxLength()) { // issue 26
                    classFileOut << "          if ("<< variableName(attr->name()) << "s.size() >= " << attr->maxLength() << ") {\n";
                    classFileOut << "              return false; // scalar already at maxOccurs\n";
                    classFileOut << "          }\n";
                }
                classFileOut << "\n        " << variableName(attr->name()) << "s.add(val);\n";
                classFileOut << "          return true;\n";
                classFileOut << "    }\n\n";
                // getter
                classFileOut << "    public " << type << " " << "get" << methodName(attr->name()) << "At(int i) {\n";
                classFileOut << "\n        return ("<< className(attr->name()) << ") " << variableName(attr->name()) << "s.get(i);\n    }\n\n";
                // count
                classFileOut << "    public int countOf" << methodName(attr->name()) << "s() {\n";
                classFileOut << "\n        return " << variableName(attr->name()) << "s.size();\n    }\n\n";
            } else {
                // setter
                classFileOut << "    public boolean set" << methodName(attr->name()) << "(" << type << " val) {\n";
                QVector<QString> enums = attr->enumeration();
                if (enums.size() > 0) { // there are enumeration constraints for this item

                    // strings should be between quotes, numbers not
                    // strings are also compared with the isEqualTo and not a simple != (issue 56)
                    if (type == "String") {
                        classFileOut << "\n        if ( ( !val.equals(\"" << enums.at(0) <<"\") ) ";
                        for (int h=1; h < enums.size(); h++) {
                            classFileOut << "&&\n             ( !val.equals(\"" << enums.at(h) << "\") ) ";
                        }
                    } else { // numbers

                        classFileOut << "\n        if ( ( val != " << enums.at(0) <<" ) ";
                        for (int h=1; h < enums.size(); h++) {
                            classFileOut << "&&\n             ( val != " << enums.at(h) << " ) ";
                        }
                    }
                    classFileOut <<    ")\n            return false;";
                }
        // issue 72
                if (attr->hasMinLength() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n        if (" << evaluator << " < " << attr->minLength() << ")\n          return false;";
                }
                if (attr->hasMaxLength() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n        if (" << evaluator << " > " << attr->maxLength() << ")\n          return false;";
                }
        // issue 72 end
                if (attr->hasMinExclusive() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n        if (" << evaluator << " <= " << attr->minExclusive() << ")\n          return false;";
                }
                if (attr->hasMaxExclusive() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n        if (" << evaluator << " >= " << attr->maxExclusive() << ")\n          return false;";
                }
                if (attr->hasMinInclusive() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n        if (" << evaluator << " < " << attr->minInclusive() << ")\n          return false;";
                }
                if (attr->hasMaxInclusive() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n        if (" << evaluator << " > " << attr->maxInclusive() << ")\n          return false;";
                }
                //if (!attr->required() || obj->isMerged()) {// issue 21
                classFileOut << "\n        " << variableName(attr->name()) << "Present = true;";
                //}
                classFileOut << "\n        " << variableName(attr->name()) << " = val;\n";
                classFileOut << "          return true;\n";
                classFileOut << "    }\n\n";
                // getter
                classFileOut << "    public " << type << " get" << methodName(attr->name()) << "() {\n";
                classFileOut << "\n        return " << variableName(attr->name()) << ";\n    }\n\n";
                if (!attr->required() || obj->isMerged()) { // issue 21 expose only optional elements
                    classFileOut << "    public boolean has" << methodName(attr->name()) << "() {\n";
                    classFileOut << "\n        return " << variableName(attr->name()) << "Present;\n    }\n\n";
                }
            }
        }

        // and fixed values
        for (int j=0; j < fixedValues.size(); j++) {
            QString attrName = fixedValues.keys().at(j);
            QString attrValue = fixedValues.values().at(j);
            QString type = "String"; // always a string

            // getter
            classFileOut << "    public " << type << " get" << methodName(attrName) << "() {\n";
            classFileOut << "\n        return \"" << attrValue << "\";\n    }\n\n";
        }

        // xml generator
        // if attribute name and type are the same it means it was data
        classFileOut << "    public String toXML() {\n\n";
        classFileOut << "        String xml = \"<" << name << "\";\n"; // append attributes
        classFileOut << "        String dataMember;";
        classFileOut << "        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n"; // issue 28, issue 55
        classFileOut << "        df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n";
        classFileOut << "        DecimalFormat nf = new DecimalFormat(\"0.000000\");\n"; // issue 63
        classFileOut << "\n";

        // for attributes
        bool hasDataMembers = false;
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString type = localType(attr->type()); // convert to java types
            QString varName = variableName(attr->name());
            QString formatDefinition;

            if (!attr->isElement()) { // issue 73

                // non-qstring items (ints) may give problems, so convert them
                if (type == "Date") {
                    varName = "df.format(" + variableName(attr->name()) + ")";
                } else if (type == "String") {
                    varName = "encode( " + variableName(attr->name()) + ")";
                } else if (type == "double") { // issue 63
                    if (attr->hasDigits()) {
                        formatDefinition = "DecimalFormat nf" + variableName(attr->name()) + " = new DecimalFormat(\"" + QString::number(0.0, 'f', attr->digits()) + "\");";
                        varName = "nf" + variableName(attr->name()) + ".format(" + variableName(attr->name()) + ")";
                    } else {
                        varName = "nf.format(" + variableName(attr->name()) + ")";
                    }
                }

                // check if the attribute exist
                if ((!attr->required() || obj->isMerged()) && !attr->isScalar()) {
                    classFileOut << "        if ( has" << methodName(attr->name()) << "() ) {\n";
                    if (!formatDefinition.isEmpty()) {
                        classFileOut << "            " + formatDefinition + "\n";
                    }
                    classFileOut << "            xml += \" " << attr->name() << "=\\\"\" + " << varName << " + \"\\\"\";\n";
                    classFileOut << "        }\n";
                } else { // issue 21
                    classFileOut << "        if ( " << variableName(attr->name()) << "Present ) {\n";
                    if (!formatDefinition.isEmpty()) {
                        classFileOut << "            " + formatDefinition + "\n";
                    }
                    classFileOut << "            xml += \" " << attr->name() << "=\\\"\" + " << varName << " + \"\\\"\";\n";
                    classFileOut << "        } else { \n";
                    classFileOut << "            return null; // not all required attributes have been set \n";
                    classFileOut << "        } \n";
                }
            } else {
                hasDataMembers = true;
            }
        }

        if (hasDataMembers) {
            classFileOut << "        xml += \">\\n\";\n"; // close the statement

            // for data members
            for (int j=0; j < attributes.size(); j++) {
                XSDAttribute *attr = attributes.at(j);
                QString attrType = attr->type();

                if (attr->isElement()) { // issue 73
                    // check if the attribute exist
                    if (attr->isScalar()) {
                        if (attr->hasMinLength()) { // issue 26
                            classFileOut << "        if (" << variableName(attr->name()) << "s.size() < " << attr->minLength() << ") {\n";
                            classFileOut << "            return null; // not enough values\n";
                            classFileOut << "        }\n";
                        }
                        if (attr->hasMaxLength()) { // issue 26
                            classFileOut << "        if (" << variableName(attr->name()) << "s.size() > " << attr->maxLength() << ") {\n";
                            classFileOut << "            return null; // too much values\n";
                            classFileOut << "        }\n";
                        }
                        classFileOut << "        for(int i=0; i < " << variableName(attr->name()) << "s.size(); i++ ) {\n";
                        classFileOut << "           " << attrType << " attribute = ("<< className(attr->name()) << ") " << variableName(attr->name()) << "s.get(i);\n";

                        if (attr->isSimpleElement()) {
                            // non-qstring items (ints) may give problems, so convert them
                            QString varName = variableName(attr->name());
                            QString formatDefinition;
                            if (attrType == "Date") {
                                varName = "df.format(" + variableName(attr->name()) + ")";
                            } else if (attrType == "String") {
                                varName = "encode( " + variableName(attr->name()) + ")";
                            } else if (attrType == "double") { // issue 63
                                if (attr->hasDigits()) {
                                    formatDefinition = "DecimalFormat nf" + variableName(attr->name()) + " = new DecimalFormat(\"" + QString::number(0.0, 'f', attr->digits()) + "\");";
                                    varName = "nf" + variableName(attr->name()) + ".format(" + variableName(attr->name()) + ")";
                                } else {
                                    varName = "nf.format(" + variableName(attr->name()) + ")";
                                }
                            }
                            classFileOut << "            xml += \"<" << attr->name() << ">\" + " << varName << " +  \"</" << attr->name() << ">\";\n";
                        } else {
                            classFileOut << "            dataMember = attribute.toXML();\n"; // issue 21
                            classFileOut << "            if (dataMember != null) {\n";
                            classFileOut << "               xml += dataMember;\n";
                            classFileOut << "            } else {\n";
                            classFileOut << "               return null; // not all required data members have been set \n";
                            classFileOut << "            } \n";
                        }
                        classFileOut << "        } \n";
                    } else if (!attr->required() || obj->isMerged()) {
                        classFileOut << "        if ( has" << methodName(attr->name()) << "() ) {\n";
                        if (attr->isSimpleElement()) {
                            classFileOut << "            xml += \"<" << attr->name() << ">\";\n";
                            classFileOut << "            xml += " << variableName(attr->name()) << ";\n";
                            classFileOut << "            xml += \"</" << attr->name() << ">\\n\";\n";
                        } else {
                            classFileOut << "            dataMember = " << " " << variableName(attr->name()) << ".toXML() ;\n";
                            classFileOut << "            if (dataMember != null) {\n"; // issue 21
                            classFileOut << "               xml += dataMember;\n";
                            classFileOut << "            } else {\n";
                            classFileOut << "               return null; // not all required data members have been set \n";
                            classFileOut << "            } \n";
                        }
                        classFileOut << "        } \n";
                    } else {
                        classFileOut << "        if ( " << variableName(attr->name()) << "Present ) {\n"; // issue 21
                        classFileOut << "            dataMember = " << " " << variableName(attr->name()) << ".toXML() ;\n";
                        classFileOut << "            if (dataMember != null) {\n"; // issue 21
                        classFileOut << "               xml += dataMember;\n";
                        classFileOut << "            } else {\n";
                        classFileOut << "               return null; // not all required data members have been set \n";
                        classFileOut << "            } \n";
                        classFileOut << "        } else { \n";
                        classFileOut << "            return null; // not all required data members have been set \n";
                        classFileOut << "        } \n";
                    }
                }
            }

            // close up
            classFileOut << "        xml += \"</" << name << ">\\n\";\n"; // append attributes
        } else {
            classFileOut << "        xml += \"/>\\n\";\n"; // close the statement
        }

        classFileOut << "        return xml;\n";
        classFileOut << "    }\n\n";

        // string generator
        // if attribute name and type are the same it means it was data
        classFileOut << "    public String toString(String lead) {\n\n";
        classFileOut << "        String str = lead + \"" << name << "\\n\";\n"; // append attributes
        classFileOut << "        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n"; // issue 28, issue 55
        classFileOut << "        DecimalFormat nf = new DecimalFormat(\"0.000000\");\n"; // issue 63
        classFileOut << "\n";

        // for attributes
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString type = localType(attr->type()); // convert to java types
            QString varName = variableName(attr->name());
            QString formatDefinition;

            if (!attr->isElement()) { //issue 73

                // non-qstring items (ints) may give problems, so convert them
                if (type == "Date") {
                    varName = "df.format(" + variableName(attr->name()) + ")";
                } else if (type == "double") { // issue 63
                    if (attr->hasDigits()) {
                        formatDefinition = "DecimalFormat nf" + variableName(attr->name()) + " = new DecimalFormat(\"" + QString::number(0.0, 'f', attr->digits()) + "\");";
                        varName = "nf" + variableName(attr->name()) + ".format(" + variableName(attr->name()) + ")";
                    } else {
                        varName = "nf.format(" + variableName(attr->name()) + ")";
                    }
                } /*else  if (type != "String") {
                   varName = "String.number(" + variableName(attr->name()) + ")";
                   } */
                // check if the attribute exist
                if ((!attr->required() || obj->isMerged()) && !attr->isScalar()) {
                    classFileOut << "        if ( has" << methodName(attr->name()) << "() ) {\n";
                    if (!formatDefinition.isEmpty()) {
                        classFileOut << "            " + formatDefinition + "\n";
                    }
                    classFileOut << "            str +=  lead + \"    " << attr->name() << " = \" + " << varName << " + \"\\n\";\n";
                    classFileOut << "        }\n";
                } else {
                    if (!formatDefinition.isEmpty()) {
                        classFileOut << "        " + formatDefinition + "\n";
                    }
                    classFileOut << "            str +=  lead + \"    " << attr->name() << " = \" + " << varName << " + \"\\n\";\n";
                }
            }
        }

        // for data members
        for (int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();

            if (attr->isElement()) {
                // check if the attribute exist
                if (attr->isScalar() ) {
                    classFileOut << "        for(int i=0; i < " << variableName(attr->name()) << "s.size(); i++ ) {\n";
                    if (attr->isSimpleElement()) {
                        // non-qstring items (ints) may give problems, so convert them
                        QString varName = variableName(attr->name());
                        QString formatDefinition;
                        if (attrType == "Date") {
                            varName = "df.format(" + variableName(attr->name()) + ")";
                        } else if (attrType == "String") {
                            varName = "encode( " + variableName(attr->name()) + ")";
                        } else if (attrType == "double") { // issue 63
                            if (attr->hasDigits()) {
                                formatDefinition = "DecimalFormat nf" + variableName(attr->name()) + " = new DecimalFormat(\"" + QString::number(0.0, 'f', attr->digits()) + "\");";
                                varName = "nf" + variableName(attr->name()) + ".format(" + variableName(attr->name()) + ")";
                            } else {
                                varName = "nf.format(" + variableName(attr->name()) + ")";
                            }
                        }
                        classFileOut << "           str += lead + \"    \" + " << varName << ";\n";
                    } else {
                        classFileOut << "           " << attrType << " attribute = ("<< className(attr->name()) << ") " << variableName(attr->name()) << "s.get(i);\n";
                        classFileOut << "           str += attribute.toString(lead + \"    \");\n        }\n";
                    }
                } else if (!attr->required() || obj->isMerged()) {
                    classFileOut << "        if ( has" << methodName(attr->name()) << "() ) {\n";
                    if (attr->isSimpleElement()) {
                        classFileOut << "            str += lead + \" \" ;\n";
                        classFileOut << "            str += \"" << attr->name() << " = \" ;\n";
                        classFileOut << "            str += " << variableName(attr->name()) << " ;\n";
                        classFileOut << "            str += \"\\n\" );\n";
                    } else {
                        classFileOut << "            str += " << " " << variableName(attr->name()) << ".toString(lead + \"    \") ;\n        }\n";
                    }
                } else {
                    classFileOut << "        str += " << " " << variableName(attr->name()) << ".toString(lead + \"    \");\n";
                }
            }
        }

        // close up
        classFileOut << "        return str;\n";
        classFileOut << "    }\n";

        // string encoder, issue 19
        classFileOut << "    public String encode( String str) {\n";
        classFileOut << "\n";
        classFileOut << "        str = str.replaceAll(\"&\", \"&amp;\");\n";
        classFileOut << "        str = str.replaceAll(\"<\", \"&lt;\");\n";
        classFileOut << "        str = str.replaceAll(\">\", \"&gt;\");\n";
        classFileOut << "        str = str.replaceAll(\"\\\"\", \"&quot;\");\n";
        classFileOut << "        return str;\n";
        classFileOut << "    }\n\n";
        // end issue 19

        // round up
        classFileOut << "\n}\n"; // make sure there is a newline at the end of the source

        // close and flush
        classFileOut.flush();
        classFile.close();
    }

    //-----------------------------------------------------------------------------------------------
    // now generate the interface
    //-----------------------------------------------------------------------------------------------

    // generate the parser file
    QString name = "ParserListener";
    QString fileName = m_outDir + "/" +  package + "/" + fileBaseName(name) + ".java";
    QFile classFile2(fileName);
    if (!classFile2.open(QIODevice::WriteOnly | QIODevice::Text)) {
        std::cerr << QString("cannot create file: %1").arg(fileName).toLatin1().data() << std::endl;
        std::exit(-1);
    }
    QTextStream classFileOut2(&classFile2);
    std::cout << QString("creating class: %1").arg(className(name)).toLatin1().data() << std::endl;

    //-----------------------------------------------------------------------------------------------
    // generate the interface declaration
    //-----------------------------------------------------------------------------------------------
    classFileOut2 << writeHeader( className(name) );

    classFileOut2 << "package " << package << ";\n\n";

    // define the interface
    classFileOut2 << "\npublic interface " << className(name) << " { \n\n";

    // public overrides
    classFileOut2 << "    // subclass these methods to receive events \n";
    for (int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        if ((obj->name() != "Schema") && (!obj->isEmbedded()) && !obj->isSimpleElement()) { // only if this object is not embedded
            classFileOut2 << "    public void handle" << className(obj->name()) << "(" << className(obj->name()) << " obj);\n";
        }
    }

    // round up
    classFileOut2 << "\n}\n"; // make sure there is a newline at the end of the source

    // close and flush
    classFileOut2.flush();
    classFile2.close();

    //-----------------------------------------------------------------------------------------------
    // now generate the parser
    //-----------------------------------------------------------------------------------------------

    // generate the parser file
    name = "Parser";
    fileName = m_outDir + "/" +  package + "/" + fileBaseName(name) + ".java";
    QFile classFile(fileName);
    if (!classFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        std::cerr << QString("cannot create file: %1").arg(fileName).toLatin1().data() << std::endl;
        std::exit(-1);
    }
    QTextStream classFileOut(&classFile);
    std::cout << QString("creating class: %1").arg(className(name)).toLatin1().data() << std::endl;

    //-----------------------------------------------------------------------------------------------
    // generate the declaration
    //-----------------------------------------------------------------------------------------------
    classFileOut << writeHeader( className(name) );

    classFileOut << "package " << package << ";\n\n";
    classFileOut << "import " << package << "." << fileBaseName("ParserListener") << ";\n";
    classFileOut << "import java.util.*;\n";
    classFileOut << "import java.util.regex.*;\n";
    classFileOut << "import java.text.DateFormat;\n";
    classFileOut << "import java.io.*;\n";
    classFileOut << "import java.text.SimpleDateFormat;\n";
    classFileOut << "import javax.xml.parsers.*;\n";
    classFileOut << "import org.xml.sax.*;\n";
    classFileOut << "import org.xml.sax.helpers.*;\n";

    // include dependend files
    for (int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        if (obj->name() != "Schema" && !obj->isSimpleElement()) { // issue 73
            classFileOut << "import " << package << "." << fileBaseName(obj->name()) << ";\n";
        }
    }

    // define the class
    classFileOut << "\npublic class " << className(name) << " extends DefaultHandler { \n\n";

    // variables
    classFileOut << "    private String m_dataBuffer = new String();\n";
    classFileOut << "    private String m_characterBuffer = new String();\n"; // issue 73
    classFileOut << "    private " << fileBaseName("ParserListener") << " m_handler =  null;\n";
    classFileOut << "    private Stack m_objStack = new Stack(); // cannot use a template since it stores different Objects\n";
    classFileOut << "    private SAXParser m_parser; // init in constructor\n";
    classFileOut << "    private Pattern m_closeTagsPattern; \n";

    // count the number of messages
    QStringList closeTags, rootObjects;
    for (int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        if ((!obj->isEmbedded()) && (obj->name() != "Schema") ) {
            rootObjects.append(obj->name());
            closeTags.append("</" + obj->name() + ">");
        }
    }

    // build a regexp for the rootTags
    QString regExp;
    QString commonPrefix = longestCommonPrefix(rootObjects);
    if (commonPrefix.size() > 0) {
        regExp = "</" + commonPrefix +  "([A-Za-z0-9]*)>";
    } else {
        regExp = closeTags.join("|");
    }

    // constructor
    classFileOut << "\n    public " << className(name) << "("<< fileBaseName("ParserListener") << " handler) {\n\n";
    classFileOut << "        m_handler = handler;\n\n";
    classFileOut << "        // set the parser\n";
    classFileOut << "        SAXParserFactory factory = SAXParserFactory.newInstance();\n";
    classFileOut << "        m_closeTagsPattern = Pattern.compile( \"" + regExp + "\");\n";

    classFileOut << "        try { \n";
    classFileOut << "            m_parser = factory.newSAXParser();\n";
    classFileOut << "        } catch(Exception e) {\n";
    classFileOut << "            e.printStackTrace();\n";
    classFileOut << "        }\n";

    classFileOut << "}\n";

    // the character parser
    classFileOut << "     // Character buffer routine\n";
    classFileOut << "     public void characters(char[] ch, int start, int length) throws SAXException {\n\n";
    classFileOut << "         m_characterBuffer += ch;\n";
    classFileOut << "     };\n";

    // main handler routine
    classFileOut << "\n    public void startElement(String namespaceUri,\n"; // the parser routine
    classFileOut << "                             String localName,\n";
    classFileOut << "                             String qName,\n";
    classFileOut << "                             Attributes atts) throws SAXException {\n\n";
    classFileOut << "         m_characterBuffer = \"\"; // reset buffer\n";

    // run through all objects
    bool first = true;
    classFileOut << "    // check all possible options\n";

    for (int i=0; i < m_objects.size(); i++) {

        XSDObject *obj = m_objects.at(i);

        // the scheme object will never be sent
        if (obj->name() == "Schema") {
            continue;
        }
        if (!first) {
            classFileOut << "    else if";
        } else {
            classFileOut << "    if";
            first = false;
        }
        // if the name matches my object
        if (!obj->isSimpleElement()) {
            classFileOut << " (qName == \"" << className(obj->name()) << "\") {\n";
            // create a temp object
            classFileOut << "        " << className(obj->name()) << " obj = new " << className(obj->name()) << "();\n";

            // check if there are attributes in this class or just data
            int attrCount = 0;
            for (int j=0; j < obj->attributes().size(); j++) {
                XSDAttribute *attr = obj->attributes().at(j);
                QString type = localType(attr->type());
                QString attrName = attr->name();

                if (attrName != type) {
                    attrCount++;
                }
            }

            // makes only sense if they are there
            if (attrCount > 0) {
                // run through all the attributes
                classFileOut << "        for (int i=0; i < atts.getLength(); i++) {\n";
                classFileOut << "            String key = atts.getLocalName(i);\n";
                classFileOut << "            String value = atts.getValue(i);\n\n";
                // and match them with mine
                bool first = true;
                for (int j=0; j < obj->attributes().size(); j++) {
                    XSDAttribute *attr = obj->attributes().at(j);
                    QString type = localType(attr->type());
                    QString attrName = attr->name();

                    if (attrName != type) { // if the same it is data
                        if (!first) {
                            classFileOut << "            else if (key == \"" << attrName << "\") {\n";
                        } else {
                            classFileOut << "            if (key == \"" << attrName << "\") {\n";
                            first = false;
                        }
                        if (type == "String")
                            classFileOut << "                " << type << " val = value;\n";
                        else if (type == "boolean") {
                            classFileOut << "                " << type << " val = (value.toUpperCase().equals(\"YES\") ||\n";
                            classFileOut << "                               value.toUpperCase().equals(\"TRUE\") ||\n";
                            classFileOut << "                               value.toUpperCase().equals(\"1\"));\n";
                        } else if (type == "int")
                            classFileOut << "                " << type << " val = Integer.parseInt(value);\n";
                        else if (type == "Date") {
                            classFileOut << "                // if the time ends on a Z it is UTC, else localtime \n"; // isssue 80
                            classFileOut << "                Date val = new Date(); // starts since the epoch\n";
                            classFileOut << "                try { \n";
                            classFileOut << "                    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\n";
                            classFileOut << "                    val = df.parse( value );\n";
                            classFileOut << "                } catch(Exception e) {\n";
                            classFileOut << "                    try { // if there are no miliseconds they will not be sent\n";
                            classFileOut << "                       DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n";
                            classFileOut << "                       val = df.parse( value );\n";
                            classFileOut << "                    } catch(Exception e2) {\n";
                            classFileOut << "                        e2.printStackTrace();\n";
                            classFileOut << "                    }\n";
                            classFileOut << "                }\n";
                        } else if (type == "double") {
                            classFileOut << "                " << type << " val = Double.parseDouble(value.replace(\",\", \".\"));\n";
                        }
                        classFileOut << "                if (! obj.set" << methodName(attrName) << "(val) ) {\n";
                        classFileOut << "                   throw new SAXException(\"Validation Exception: \" + key + \" = \" + value );\n";
                        classFileOut << "                }\n";
                        classFileOut << "            }\n";
                    }
                }
                classFileOut << "        }\n";
            }

            // store in local object (or stack) and signal on end tag
            // this way we can set obj in objects
            classFileOut << "        m_objStack.push( obj );\n";
        } else {
            classFileOut << "        // data will follow and end up in the m_characterBuffer\n";
        }
        classFileOut << "    }\n";
    }
    //classFileOut << "    return true;\n";
    classFileOut << "}\n\n";

    // TODO check for attributes and messages we do not know and give an alert

    // the endTag routine
    classFileOut << "    public void endElement(String namespaceUri,\n"; // the parser routine
    classFileOut << "                           String localName,\n";
    classFileOut << "                           String qName) throws SAXException {\n\n";

    // run through all objects
    first = true;
    classFileOut << "    // check all possible options\n";

    for (int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        // the scheme object will never be sent
        if (obj->name() == "Schema") {
            continue;
        }
        if (!first) {
            classFileOut << "    else if";
        } else {
            classFileOut << "    if";
            first = false;
        }
        // if the name matches my object
        classFileOut << " (qName == \"" << className(obj->name()) << "\") {\n\n";

        if (!obj->isSimpleElement()) { // normal flow
            //classFileOut << "        m_typeStack.pop();\n"; // will be equal to qName so ignore
            classFileOut << "        " << className(obj->name()) << " obj = (" << className(obj->name()) << ") ( m_objStack.pop() );\n";

            // for all objects that could accept such an object
            for (int i=0; i < m_objects.size(); i++) {
                XSDObject *parent = m_objects.at(i);

                for (int j=0; j < parent->attributes().size(); j++) {
                    XSDAttribute *attr = parent->attributes().at(j);
                    QString objType = attr->type();

                    if (objType == className(obj->name())) { // this object has an attribute of that type
                        classFileOut << "        if ( m_objStack.peek().getClass() == new " << parent->name() << "().getClass() ) {\n";
                        if (attr->isScalar() ) {
                            classFileOut << "                if (! (("<< parent->name() << ") ( m_objStack.peek() ) ).add" << className(obj->name()) << "( obj ) ) {\n";
                            classFileOut << "                   throw new SAXException(\"Validation Exception: \" + qName);\n";
                            classFileOut << "                }\n";
                        } else {
                            classFileOut << "                if (! (("<< parent->name() << ") ( m_objStack.peek() ) ).set" << className(obj->name()) << "( obj ) ) {\n";
                            classFileOut << "                   throw new SAXException(\"Validation Exception: \" + qName);\n";
                            classFileOut << "                }\n";
                        }
                        classFileOut << "        }\n"; // close if
                    }
                }
            }
            if ((!obj->isEmbedded())) { // only if this object is not embedded
                classFileOut << "        if (m_handler != null) \n";
                classFileOut << "            m_handler.handle" << className(obj->name()) << "( obj ); \n";
            }
            //classFileOut << "        delete( obj ); \n";
        } else { // closed element is not an element with properties but a data holder, this is stored at the parent level

            // for all objects that could accept such an object
            for (int i=0; i < m_objects.size(); i++) {
                XSDObject *parent = m_objects.at(i);

                for (int j=0; j < parent->attributes().size(); j++) {
                    XSDAttribute *attr = parent->attributes().at(j);
                    //std::cout << QString("####: %1").arg(attr->name()).toLatin1().data() << std::endl;
                    //std::cout << QString("##: %1").arg(obj->name()).toLatin1().data() << std::endl;

                    if (obj->name() == attr->name() ) { // this object has an datamember of that type

                        classFileOut << "        " << className(parent->name()) << " *parent = (" << className(parent->name()) << ") ( m_objStack.top() );\n";
                        classFileOut << "        if (parent) {\n";
                        classFileOut << "             // add the found characters to the parent\n";
                        if (attr->isScalar()) {
                            classFileOut << "             parent.add" << className(obj->name()) << "(m_characterBuffer);\n";
                        } else {
                            classFileOut << "             parent.set" << className(obj->name()) << "(m_characterBuffer);\n";
                        }
                        classFileOut << "             // clear the character buffer\n";
                        classFileOut << "             m_characterBuffer = "";\n";
                        classFileOut << "        }\n";
                    }
                }
            }
        }
        classFileOut << "    }\n"; // close if
    }
    //classFileOut << "    return true;\n";
    classFileOut << "}\n\n"; // close method

    // the parseXMLString routine
    // rewritten for issue 60
    classFileOut << "    public boolean parseXMLString(String data, boolean cont) { \n\n";
    classFileOut << "     m_dataBuffer += data;\n\n";
    classFileOut << "\n";
    classFileOut << "     // search the buffer for the nearest closetag\n";
    classFileOut << "     int indexStart = 0, indexEnd = -1;\n";
    classFileOut << "\n";
    classFileOut << "     // look for the pattern that defines a root element\n";
    classFileOut << "     Matcher matcher = m_closeTagsPattern.matcher( m_dataBuffer );\n";
    classFileOut << "\n";
    classFileOut << "     // parse the messages in the buffer one by one\n";
    classFileOut << "     while ( matcher.find() ) {\n";
    classFileOut << "         indexEnd = matcher.end();\n";
    classFileOut << "         // isolate the messages\n";
    classFileOut << "         String messages = m_dataBuffer.substring(indexStart, indexEnd);\n";
    classFileOut << "         indexStart = indexEnd;\n";
    classFileOut << "         // and parse\n";
    classFileOut << "         try { \n";
    classFileOut << "             m_parser.parse(new InputSource(new StringReader(messages)), this);\n";
    classFileOut << "         } catch(Exception e) {\n";
    classFileOut << "             String errorMessage =\n";
    classFileOut << "             \"Error parsing \" + messages + \": \" + e;\n";
    classFileOut << "             System.err.println(errorMessage);\n";
    classFileOut << "             e.printStackTrace();\n";
    classFileOut << "             return false;\n";
    classFileOut << "         }\n";
    classFileOut << "     }\n";
    classFileOut << "\n";
    classFileOut << "     // check if we parsed messages\n";
    classFileOut << "     if (indexEnd > -1) {\n";
    classFileOut << "         // remove from buffer\n";
    classFileOut << "         m_dataBuffer = m_dataBuffer.substring(indexEnd);\n";
    classFileOut << "     }\n";
    classFileOut << "\n";
    classFileOut << "     // check if we should flush the buffer\n";
    classFileOut << "     if (!cont) {\n";
    classFileOut << "         m_dataBuffer = \"\";\n";
    classFileOut << "     }\n";
    classFileOut << "     return true;\n";
    classFileOut << "}\n\n"; // close method

    // round up
    classFileOut << "\n}\n"; // make sure there is a newline at the end of the source

    // close and flush
    classFileOut.flush();
    classFile.close();
    std::cout << "done.\n" << std::endl;
}

