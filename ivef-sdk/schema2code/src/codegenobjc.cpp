/*
 *  codegenqt.cpp
 *
 *  schema2code is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  schema2code is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Created by Lukassen on 11/06/08.
 *  Copyright 2009
 *
 */

#include <cstdlib>

#include "codegenobjc.h"

CodeGenObjC::CodeGenObjC()
: CodeGen()
{
    m_prefix = "";
}

void CodeGenObjC::setObjects(QVector<XSDObject*>objects) {
    m_objects = objects;
}

void CodeGenObjC::setOutputDir(QString outDir) {
    m_outDir = outDir;
}

QString CodeGenObjC::sizeEvaluatorForType (QString type, QString varName) {
    if (type == "xs:string")
        return "[" + varName + " length]";
    else if (type == "xs:hexBinary") // or should it by a QByteArray?
        return "[" + varName + " length]";
    else
        return varName;
}

QString CodeGenObjC::localType(QString type) {
    if (type == "xs:string")
        return "NSString *";
    else if (type == "xs:boolean")
        return "BOOL";
    else if (type == "xs:integer")
        return "int";
    else if (type == "xs:hexBinary")
        return "NSString *";
    else if (type == "xs:dateTime")
        return "NSDate *";
    else if (type == "unknown") {
        std::cout << "WARNING unknown type found, defaulting to NSString" << std::endl;
        return "NSString *";
    }
    else if (type == "xs:decimal") // float
        return "float";
    else
        return m_prefix + type + " *";
}

bool CodeGenObjC::knownType(QString type) {
    if (type == "xs:string")
        return true;
    else if (type == "xs:boolean")
        return true;
    else if (type == "xs:integer")
        return true;
    else if (type == "xs:hexBinary")
        return true;
    else if (type == "xs:dateTime")
        return true;
    else if (type == "unknown")
        return true;
    else if (type == "xs:decimal") // float
        return true;
    else
        return false;
}

QString CodeGenObjC::fileBaseName(QString name) {
    return m_prefix + name;
}

QString CodeGenObjC::className(QString name) {
    return m_prefix + methodName(name);
}

QString CodeGenObjC::getMethodName(QString name) { // issue 30
    if (name == "Id") {
        name = "Ident"; // protected name in obj-C
    }

    if (name.left(2).toUpper() == name.left(2)) { // var starts with XX
        return name;
    } else {
        return name.replace(0, 1, name.left(1).toLower());
    }
}

QString CodeGenObjC::setMethodName(QString name) { // issue 30
    if (name == "Id") {
        name = "Ident"; // protected name in obj-C
    }
    return "set" + methodName(name);
}

QString CodeGenObjC::methodName(QString name) {
    if (name.left(2).toUpper() == name.left(2)) { // all in caps
        return name;
    } else {
        return name.replace(0, 1, name.left(1).toUpper());
    }
}

QString CodeGenObjC::variableName(QString name) {

    if (name.mid(1,1).toUpper() == name.mid(1,1)) { // if second char is uppercase
        return "m_" + name;
    } else {
        return "m_" + name.replace(0, 1, name.left(1).toLower());
    }
}

QString CodeGenObjC::writeHeader(QString fileName) {

    QString header;
    header.append( "/* \n" );
    header.append( " *  " + fileName + "\n" );
    header.append( " *\n" );
    header.append( " *  " + fileName + " is free software: you can redistribute it and/or modify\n" );
    header.append( " *  it under the terms of the GNU Lesser General Public License as published by\n" );
    header.append( " *  the Free Software Foundation, either version 3 of the License, or\n" );
    header.append( " *  (at your option) any later version.\n" );
    header.append( " *\n" );
    header.append( " *  Foobar is distributed in the hope that it will be useful,\n" );
    header.append( " *  but WITHOUT ANY WARRANTY ); without even the implied warranty of\n" );
    header.append( " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" );
    header.append( " *  GNU General Public License for more details.\n" );
    header.append( " *\n" );
    header.append( " **********************************************************************************\n" );
    header.append( " *  WARNING: THIS CODE WAS GENERATED DO NOT MODIFY, CHANGE THE XSD INSTEAD\n" );
    header.append( " *  Generated by schema2code on "+  QDateTime::currentDateTime().toString() + ".\n" );
    header.append( " **********************************************************************************\n" );
    header.append( " *  Copyright 2010\n" );
    header.append( " *\n" );
    header.append( " */\n\n" );

    return header;
}

void CodeGenObjC::go() {

    // first analyse the objects if they are embedded objects
    // for all objects that could accept such an object
    for(int i=0; i < m_objects.size(); i++) {
        // for all objects
        XSDObject *obj1 = m_objects.at(i);
        obj1->setSimpleElement(false); // assume not

        // find if there is another object that refers to the obj
        for(int h=0; h < m_objects.size(); h++) {

            XSDObject *obj2 = m_objects.at(h);

            // refers means obj2 has an attribute of type obj1
            for(int j=0; j < obj2->attributes().size(); j++) {
                XSDAttribute *attr = obj2->attributes().at(j);
                QString objType = attr->type();

                // if obj1 is a simple element of obj2 we don't need to generate a class for it
                if (attr->isSimpleElement() && attr->name() == obj1->name()) {
                    //std::cout << QString("Should i ignore attr: %1 for obj2 %2 obj1 %3?").arg(attr->name(), obj2->name(), obj1->name()).toLatin1().data() << std::endl;
                    obj1->setSimpleElement(true);
                    std::cout << QString("marking class: %1 for skip").arg(className(obj1->name())).toLatin1().data() << std::endl;

                }

                if (objType == obj1->name()) {
                    obj1->setEmbedded();    // obj1 is embedded in obj2
                }
            }
        }
    }

    for(int i=0; i < m_objects.size(); i++) {
        // get a class
        XSDObject *obj = m_objects.at(i);

        // get some vars we frequently use
        QString name = obj->name();
        QString upperName = name.toUpper();
        QVector<XSDAttribute*>attributes = obj->attributes();
        QMap<QString, QString>fixedValues = obj->fixedValues();

        // check for simple elements
        if (obj->isSimpleElement()) {
            std::cout << QString("skipping class: %1").arg(className(name)).toLatin1().data() << std::endl;
            continue;
        }

        // report
        std::cout << QString("creating class: %1").arg(className(name)).toLatin1().data() << std::endl;

        // open the header file
        QString baseName = m_outDir + "/" + fileBaseName(name);
        QFile headerFile(baseName + ".h");
        if (!headerFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            std::cerr << QString("cannot create file: %1").arg(baseName + ".h").toLatin1().data() << std::endl;
            std::exit(-1);
        }
        QTextStream headerFileOut(&headerFile);

        // and the class file
        QFile classFile(baseName + ".m");
        if (!classFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            std::cerr << QString("cannot create file: %1").arg(baseName + ".m").toLatin1().data() << std::endl;
            std::exit(-1);
        }
        QTextStream classFileOut(&classFile);

        //-----------------------------------------------------------------------------------------------
        // generate the header
        //-----------------------------------------------------------------------------------------------
        headerFileOut << writeHeader( className(name) );

        //headerFileOut << "#ifndef __" << upperName << "_H__\n";
        //headerFileOut << "#define __" << upperName << "_H__\n\n";
        headerFileOut << "#import <Foundation/Foundation.h>\n";

        // include dependend files
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            if(!knownType(attr->type())) {
                headerFileOut << "#import \"" << fileBaseName(attr->type()) << ".h\"\n";
            }
        }

        QString docu = obj->docu();
        if (docu != "") { // there is documentation
            docu.replace("\n", "\\n\n//! ");
            docu.replace("\r", "");
        }

        headerFileOut << "\n//-----------------------------------------------------------\n";
        headerFileOut << "//! \\brief       Class definition of " << className(name) << "\n";
        headerFileOut << "//!\n";
        headerFileOut << "//! " << docu << "\n";
        headerFileOut << "//!\n";

        // define the class
        QString baseClass = "NSObject";
        if (obj->hasBaseClass()) {
            baseClass = obj->baseClass();
        }
        headerFileOut << "\n@interface " << className(name) << " : " << baseClass << " { \n";

        // variables  section
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = localType(attr->type()); // convert to cpp types
            // definition
            if (attr->isScalar()) { // there more then one
                headerFileOut << "    NSMutableArray *" << variableName(attr->name()) << "s;\n";
            } else if (attrType.right(1) != "*") {
                headerFileOut << "    " << attrType << " " << variableName(attr->name()) << ";\n";
            } else {
                headerFileOut << "    " << attrType << variableName(attr->name()) << ";\n";
            }
            //if (!attr->required() || obj->isMerged()) { // issue 21
            headerFileOut << "    BOOL " << variableName(attr->name()) << "Present;\n";
        }
        headerFileOut << "}\n\n";

        // methods section

        // all attributes
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = localType(attr->type()); // convert to local types
            QString doc = attr->doc();
            if (doc != "") { // there is documentation
                doc.replace("\n", "\n   ");
                doc.replace("\r", "");
                headerFileOut << "\n/* " << methodName(attr->name()) << ":\n   " << doc << " */\n";
            }
            if (attr->isScalar()) { // there more then one
                // remover issue 70
                headerFileOut << "//!Remover for " << methodName(attr->name()) << "\n";
                headerFileOut << "//!\n";
                headerFileOut << "-(BOOL) remove" << methodName(attr->name()) << ":(" << attrType << ") val;\n";

                // setter
                headerFileOut << "//!Setter for " << methodName(attr->name()) << "\n";
                headerFileOut << "//!\n";
                headerFileOut << "-(BOOL) add" << methodName(attr->name()) << ":(" << attrType << ") val;\n";

                // getter
                headerFileOut << "//!Getter for " << methodName(attr->name()) << "\n";
                headerFileOut << "//!\n";
                headerFileOut << "-(" << attrType << ") " << getMethodName(attr->name()) << "At:(int) i;\n";
                // count
                headerFileOut << "//!Element counter for " << methodName(attr->name()) << "\n";
                headerFileOut << "//!\n";
                headerFileOut << "-(int) countOf" << methodName(attr->name()) << "s;\n";
                // all
                headerFileOut << "//!Get all elements for " << methodName(attr->name()) << "\n";
                headerFileOut << "//!\n";
                headerFileOut << "-(NSArray *) " << getMethodName(attr->name()) << "s;\n";
            } else {
                // setter
                if (!attr->isFixed()) { // fixed attributes cannot be set
                    headerFileOut << "//!Setter for " << methodName(attr->name()) << "\n";
                    headerFileOut << "//!\n";
                    headerFileOut << "-(BOOL) " << setMethodName(attr->name()) << ":(" << attrType << ") val;\n";
                }
                // getter
                headerFileOut << "//!Getter for " << methodName(attr->name()) << "\n";
                headerFileOut << "//!\n";
                headerFileOut << "-(" << attrType << ") " << getMethodName(attr->name()) << ";\n";
                if (!attr->required() || obj->isMerged()) {
                    headerFileOut << "//!Test for pressence of " << methodName(attr->name()) << "\n";
                    headerFileOut << "//!\n";
                    headerFileOut << "-(BOOL) has" << methodName(attr->name()) << ";\n";
                }
            }
        }
        // and fixed values
        for(int j=0; j < fixedValues.size(); j++) {
            QString attrName = fixedValues.keys().at(j);
            QString attrType = "NSString"; // always a string
            // getter
            headerFileOut << "//!Getter for " << methodName(attrName) << "\n";
            headerFileOut << "//!\n";
            headerFileOut << "-(" << attrType << "*) " << getMethodName(attrName) << ";\n";
        }
        headerFileOut << "//!Set attributes by providing a key/value dictionary\n";
        headerFileOut << "//!\n";
        headerFileOut << "\n-(BOOL) setAttributes:(NSDictionary *)attributeDict;\n";
        headerFileOut << "//!Get attributes as a key/value dictionary\n";
        headerFileOut << "//!\n";
        headerFileOut << "-(NSDictionary *) attributes;\n"; // issue 32
        headerFileOut << "//!Get a XML representation of this class\n";
        headerFileOut << "//!returns nil if not all required fields are set\n";
        headerFileOut << "//!\n";
        headerFileOut << "-(NSString *) XML;\n";
        headerFileOut << "//!Get a string representation of this class\n";
        headerFileOut << "//!\n";
        headerFileOut << "-(NSString *) stringValue;\n";
        headerFileOut << "-(NSString *) stringValueWithLead:(NSString *) lead;\n";
        headerFileOut << "//!Helper routine to encode any string to an XML escaped string\n";
        headerFileOut << "//!\n";
        headerFileOut << "-(NSString *) encode: (NSString *) input;\n"; // issue 19

        // close the header
        headerFileOut << "\n@end\n\n";
        headerFileOut << "\n\n";
        //headerFileOut << "\n#endif\n\n";

        // close and flush
        headerFileOut.flush();
        headerFile.close();

        //-----------------------------------------------------------------------------------------------
        // create the class file
        //-----------------------------------------------------------------------------------------------
        classFileOut << "\n#import \"" << fileBaseName(name) << ".h\"\n\n";
        classFileOut << "\n@implementation " << className(name) << "\n\n";

        // constructor
        classFileOut << "- (id) init {\n    self = [super init];\n    if (self != nil) {\n";
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString niceVarName  = attr->name().replace(0, 1, attr->name().left(1).toLower());
            if (attr->isScalar()) { // there more then one
                classFileOut << "        " << variableName(attr->name()) << "s = [[NSMutableArray alloc] init];\n";
            }
            if (attr->isFixed()) { // we already know the value and it cannot be changed (no setter)
                classFileOut << "        " << variableName(attr->name()) << " = @\"" << attr->fixed() << "\";\n";
                classFileOut << "        " << variableName(attr->name()) << "Present = YES;\n";
            } else {
                //if (!attr->required() || obj->isMerged()) { // issue 21
                classFileOut << "        " << variableName(attr->name()) << "Present = NO;\n";
            }
        }
        classFileOut << "    }\n    return self;\n}\n\n";

        // destructor
        classFileOut << "- (void) dealloc {\n\n";
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = localType(attr->type()); // convert to cpp types
            if (attr->isScalar()) { // there more then one
                classFileOut << "    [" << variableName(attr->name()) << "s release];\n";
            } else if (attrType.right(1) == "*") { // its a dynamic type
                classFileOut << "    [" <<  variableName(attr->name()) << " release];\n";
            }
        }
        classFileOut << "    [super dealloc];\n";
        classFileOut << "}\n\n";

        // date parsing
        classFileOut << "- (NSString*) stringFromDate:(NSDate *)date {\n\n";
        classFileOut << "     // new date strings can be in Zulu time\n";
        classFileOut << "     static NSDateFormatter *formatterWithMillies = nil;\n";
    classFileOut << "     NSTimeZone *timeZone = [NSTimeZone timeZoneWithName:@\"UTC\"];\n";
        classFileOut << "     if (date == nil) {\n";
        classFileOut << "         return @\"\"; // illigal date\n";
        classFileOut << "     }\n";
        classFileOut << "     if (formatterWithMillies == nil) {\n";  // NEXTSTEP format!
        classFileOut << "         formatterWithMillies = [[NSDateFormatter alloc] initWithDateFormat: @\"%Y-%m-%dT%H:%M:%S.%F\" allowNaturalLanguage:NO];\n";
        //classFileOut << "         formatterWithMillies = [[NSDateFormatter alloc] initWithDateFormat: @\"yyyy-MM-dd'T'HH:mm:ss.SSS\" allowNaturalLanguage:NO];\n";
        classFileOut << "     }\n";
    classFileOut << "     [formatterWithMillies setTimeZone:timeZone];\n";
        classFileOut << "#if defined (__clang__)\n";
        classFileOut << "     return [[formatterWithMillies stringForObjectValue:date] stringByAppendingString:@\"Z\"]; // always zulu time\n";
        classFileOut << "#else\n";
        classFileOut << "     return [[formatterWithMillies stringFromDate:date] stringByAppendingString:@\"Z\"]; // always zulu time\n";
        classFileOut << "#endif\n";
        classFileOut << "}\n\n";

        classFileOut << "- (NSDate*) dateFromString:(NSString *)str {\n\n";
        classFileOut << "     static NSDateFormatter *formatterWithMillies = nil;\n";
        classFileOut << "     if (formatterWithMillies == nil) {\n";
        classFileOut << "         formatterWithMillies = [[NSDateFormatter alloc] initWithDateFormat: @\"%Y-%m-%dT%H:%M:%S.%F\" allowNaturalLanguage:NO];\n";
        //classFileOut << "         formatterWithMillies = [[NSDateFormatter alloc] initWithDateFormat: @\"yyyy-MM-dd'T'HH:mm:ss.SSS\" allowNaturalLanguage:NO];\n";
        classFileOut << "     }\n";
        classFileOut << "     static NSDateFormatter *formatterWithSeconds = nil;\n";
        classFileOut << "     if (formatterWithSeconds == nil) {\n";
        classFileOut << "         formatterWithSeconds = [[NSDateFormatter alloc] initWithDateFormat: @\"%Y-%m-%dT%H:%M:%S\" allowNaturalLanguage:NO];\n";
        //classFileOut << "         formatterWithSeconds = [[NSDateFormatter alloc] initWithDateFormat: @\"yyyy-MM-dd'T'HH:mm:ss\" allowNaturalLanguage:NO];\n";
        classFileOut << "     }\n";
        classFileOut << "     static NSDateFormatter *formatterWithMinutes = nil;\n";
        classFileOut << "     if (formatterWithMinutes == nil) {\n";
        classFileOut << "         formatterWithMinutes = [[NSDateFormatter alloc] initWithDateFormat: @\"%Y-%m-%dT%H:%M\" allowNaturalLanguage:NO];\n";
        //classFileOut << "         formatterWithMinutes = [[NSDateFormatter alloc] initWithDateFormat: @\"yyyy-MM-dd'T'HH:mm\" allowNaturalLanguage:NO];\n";
        classFileOut << "     }\n";
        classFileOut << "     // new date strings can be in Zulu time\n";
    classFileOut << "     NSTimeZone *timeZone = [NSTimeZone timeZoneWithName:@\"UTC\"];\n";
    classFileOut << "     if ([str characterAtIndex: [str length] - 1] == 'Z') {\n";
    classFileOut << "         [formatterWithMillies setTimeZone:timeZone]; // localtime is default\n";
    classFileOut << "         [formatterWithSeconds setTimeZone:timeZone]; // localtime is default\n";
    classFileOut << "         [formatterWithMinutes setTimeZone:timeZone]; // localtime is default\n";
        classFileOut << "#if defined (__clang__)\n";
        classFileOut << "         str = [str stringByReplacingString:@\"Z\" withString:@\"\"];\n\n";
        classFileOut << "#else\n";
        classFileOut << "         str = [str stringByReplacingOccurrencesOfString:@\"Z\" withString:@\"\"];\n\n";
        classFileOut << "#endif\n";
    classFileOut << "     }\n";
    classFileOut << "     // convert\n";
        classFileOut << "#if defined (__clang__)\n";
        classFileOut << "     NSDate *val;\n";
        classFileOut << "     [formatterWithMillies getObjectValue: &val forString: str errorDescription: nil];\n";
        classFileOut << "#else\n";
        classFileOut << "     NSDate *val = [formatterWithMillies dateFromString:str];\n";
        classFileOut << "#endif\n";
        classFileOut << "     if (val) {\n";
        classFileOut << "         return val;\n";
        classFileOut << "     }\n";
        classFileOut << "#if defined (__clang__)\n";
        classFileOut << "     [formatterWithSeconds getObjectValue: &val forString: str errorDescription: nil];\n";
        classFileOut << "#else\n";
        classFileOut << "     val = [formatterWithSeconds dateFromString:str];\n";
        classFileOut << "#endif\n";
        classFileOut << "     if (val) {\n";
        classFileOut << "         return val;\n";
        classFileOut << "     }\n";
        classFileOut << "#if defined (__clang__)\n";
        classFileOut << "     [formatterWithMinutes getObjectValue: &val forString: str errorDescription: nil];\n";
        classFileOut << "#else\n";
        classFileOut << "     val = [formatterWithMinutes dateFromString:str];\n";
        classFileOut << "#endif\n";
        classFileOut << "     if (val) {\n";
        classFileOut << "         return val;\n";
        classFileOut << "     }\n";
        classFileOut << "     return nil; // invalid date\n";
        classFileOut << "}\n\n";

        // methods for attributes
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString myType = localType(attr->type()); // convert to cpp types
            if (attr->isScalar()) { // there more then one
                // remover issue 70
                classFileOut << "-(BOOL) remove" << methodName(attr->name()) << ":(" << myType << ") val {\n";

                if (attr->hasMinOccurs()) {
                    classFileOut << "    if ([" << variableName(attr->name()) << "s count] <= " << attr->minOccurs() << ") {\n";
                    classFileOut << "        return NO; // scalar already at minOccurs\n";
                    classFileOut << "    }\n";
                }

                classFileOut << "\n    [" << variableName(attr->name()) << "s removeObject: val];\n";
                classFileOut << "    return YES;\n";
                classFileOut << "}\n\n";

                // setter
                classFileOut << "-(BOOL) add" << methodName(attr->name()) << ":(" << myType << ") val {\n";

                if (attr->hasMaxOccurs()) { // issue 26
                    classFileOut << "    if ([" << variableName(attr->name()) << "s count] >= " << attr->maxOccurs() << ") {\n";
                    classFileOut << "        return NO; // scalar already at maxOccurs\n";
                    classFileOut << "    }\n";
                }
                if (attr->hasMinLength() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n    if (" << evaluator << " < " << attr->minLength() << ")\n        return NO;";
                }
                if (attr->hasMaxLength() && knownType(attr->type()) ) {
                    QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                    classFileOut << "\n    if (" << evaluator << " > " << attr->maxLength() << ")\n        return NO;";
                }

                classFileOut << "\n    [" << variableName(attr->name()) << "s addObject: val];\n";
                classFileOut << "    return YES;\n";
                classFileOut << "}\n\n";

                // getter
                classFileOut << "-(" << myType << ") " << getMethodName(attr->name()) << "At:(int) i {\n";
                classFileOut << "\n    return [" << variableName(attr->name()) << "s objectAtIndex: i];\n}\n\n";
                // count
                classFileOut << "-(int) countOf" << methodName(attr->name()) << "s {\n";
                classFileOut << "\n    return [" << variableName(attr->name()) << "s count];\n}\n\n";
                // reference to all
                classFileOut << "-(NSArray *) " << getMethodName(attr->name()) << "s {\n";
                classFileOut << "\n    return " << variableName(attr->name()) << "s;\n}\n\n";
            } else {
                // setter
                if (!attr->isFixed()) { // fixed attributes cannot be set
                    classFileOut << "-(BOOL) " << setMethodName(attr->name()) << ":(" << myType << ") val {\n";
                    QVector<QString> enums = attr->enumeration();
                    if (enums.size() > 0) { // there are enumeration constraints for this item

                        // strings should be between quotes, numbers not
                        QString quote;
                        if (myType != localType("xs:string")) {
                            classFileOut << "\n    if ( ( val != " << enums.at(0) << " ) ";
                            for (int h=1; h < enums.size(); h++) {
                                classFileOut << "&&\n         ( val != " << enums.at(h) << " ) ";
                            }
                        } else {
                            classFileOut << "\n    if ( ( ![val isEqualToString: @\"" << enums.at(0) << "\"] ) ";
                            for (int h=1; h < enums.size(); h++) {
                                classFileOut << "&&\n         ( ![val isEqualToString: @\"" << enums.at(h) << "\"] ) ";
                            }
                        }
                        classFileOut <<    ")\n        return NO;";
                    }
            // issue 72 start
                    if (attr->hasMinLength() && knownType(attr->type()) ) {
                        QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                        classFileOut << "\n    if (" << evaluator << " < " << attr->minLength() << ")\n        return NO;";
                    }
                    if (attr->hasMaxLength() && knownType(attr->type()) ) {
                        QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                        classFileOut << "\n    if (" << evaluator << " > " << attr->maxLength() << ")\n        return NO;";
                    }
            // issue 72 stop
                    if (attr->hasMinExclusive() && knownType(attr->type()) ) {
                        QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                        classFileOut << "\n    if (" << evaluator << " <= " << attr->minExclusive() << ")\n        return NO;";
                    }
                    if (attr->hasMaxExclusive() && knownType(attr->type()) ) {
                        QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                        classFileOut << "\n    if (" << evaluator << " >= " << attr->maxExclusive() << ")\n        return NO;";
                    }
                    if (attr->hasMinInclusive() && knownType(attr->type()) ) {
                        QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                        classFileOut << "\n    if (" << evaluator << " < " << attr->minInclusive() << ")\n        return NO;";
                    }
                    if (attr->hasMaxInclusive() && knownType(attr->type()) ) {
                        QString evaluator = sizeEvaluatorForType(attr->type(), "val");
                        classFileOut << "\n    if (" << evaluator << " > " << attr->maxInclusive() << ")\n        return NO;";
                    }
                    //if (!attr->required() || obj->isMerged()) {  // issue 21
                    classFileOut << "\n    " << variableName(attr->name()) << "Present = YES;";
                    classFileOut << "\n";
                    if (myType.right(1) == "*") {
                        classFileOut << "    [" << variableName(attr->name()) << " release];\n";
                    }
                    classFileOut << "    " << variableName(attr->name()) << " = val;\n";
                    if (myType.right(1) == "*") {
                        classFileOut << "    [" << variableName(attr->name()) << " retain];\n";
                    }
                    classFileOut << "    return YES;\n";
                    classFileOut << "}\n\n";
                }

                // getter
                classFileOut << "- (" << myType << ") " << getMethodName(attr->name()) << " {\n";
                classFileOut << "\n    return " << variableName(attr->name()) << ";\n}\n\n";
                if (!attr->required() || obj->isMerged()) { // issue 21 test only for optional elements
                    classFileOut << "-(BOOL) has" << methodName(attr->name()) << " {\n";
                    classFileOut << "\n    return " << variableName(attr->name()) << "Present;\n}\n\n";
                }
            }
        }

        // and fixed values
        for(int j=0; j < fixedValues.size(); j++) {
            QString attrName = fixedValues.keys().at(j);
            QString attrValue = fixedValues.values().at(j);
            QString type = localType("xs:string"); // always a string

            // getter
            classFileOut << "-(" << type << ") " << getMethodName(attrName) << " {\n";
            classFileOut << "\n    return @\"" << attrValue << "\";\n}\n\n";
        }

        // set attributes from a dict
        classFileOut << "-(BOOL) setAttributes:(NSDictionary *)attributeDict {\n\n";

        // check if there are attributes in this class or just data
        int attrCount = 0;
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = localType(attr->type());
            QString attrName = attr->name();

            if (!attr->isElement()) {
                attrCount++;
            }
        }

        // makes only sense if they are there
        if (attrCount > 0) {
            // run through all the attributes
            classFileOut << "#if defined (__clang__)\n";
            classFileOut << "        NSEnumerator *enumerator = [attributeDict keyEnumerator];\n";
            classFileOut << "        NSString *key;\n";
            classFileOut << "        while (key = [enumerator nextObject]) {\n";
            classFileOut << "#else\n";
            classFileOut << "        for (NSString *key in attributeDict) {\n";
            classFileOut << "#endif\n";
            // and match them with mine
            bool first = true;
            for(int j=0; j < attributes.size(); j++) {
                XSDAttribute *attr = attributes.at(j);
                QString attrType = localType(attr->type());
                QString attrName = attr->name();

                if (!attr->isElement()) {// if the same it is data
                    if (!first) {
                        classFileOut << "            else if ([key isEqualToString:@\"" << attrName << "\"]) {\n";
                    } else {
                        classFileOut << "            if ([key isEqualToString: @\"" << attrName << "\"]) {\n";
                        first = false;
                    }

                    if (attrType == localType("xs:string")) {
                        classFileOut << "                NSString *val = [attributeDict objectForKey: key];\n";
                    } else if (attrType == localType("xs:boolean")) {
                        classFileOut << "                NSString *value = [attributeDict objectForKey: key];\n";
                        classFileOut << "                " << attrType << " val = ([[value uppercaseString] isEqualToString: @\"YES\"] || \n";
                        classFileOut << "                            [[value uppercaseString] isEqualToString: @\"TRUE\"] ||\n";
                        classFileOut << "                            [[value uppercaseString] isEqualToString: @\"1\"]);\n";
                    } else if (attrType == localType("xs:integer")) {
                        classFileOut << "                NSString *value = [attributeDict objectForKey: key];\n";
                        classFileOut << "                " << attrType << " val = [value intValue];\n";
                    } else if (attrType == localType("xs:dateTime")) {
                        classFileOut << "                NSString *value = [attributeDict objectForKey: key];\n";
                        classFileOut << "                NSDate *val = [self dateFromString: value];\n";
                    } else if (attrType == localType("xs:decimal")) {
                        classFileOut << "                NSString *value = [attributeDict objectForKey: key];\n";
                        classFileOut << "                " << attrType << " val = [value floatValue];\n";
                    } else {
                        classFileOut << "                " << attrType << " val = [attributeDict objectForKey: key];\n";
                    }

                    if (attr->isScalar() ) {
                        classFileOut << "                if (![self add" << methodName(attrName) << ": val]) {\n                   return NO;\n                }\n";
                    } else if (!attr->isFixed()){
                        classFileOut << "                if (![self " << setMethodName(attrName) << ": val]) {\n                   return NO;\n                }\n";
                    } else {
                        // what to do, we get a fixed attribute which may be different from our own!
                        classFileOut << "                [" << variableName(attrName) << " release]; \n";
                        classFileOut << "                " << variableName(attrName) << " = val; // replace the default versioning number\n";
                        classFileOut << "                " << variableName(attr->name()) << "Present = YES;\n"; // issue 21
                        classFileOut << "                [" << variableName(attrName) << " retain]; \n";
                    }

                    if (attr->isScalar() ) {
                        classFileOut << "                if (![self add" << methodName(attrName) << ": val]) {\n                   return NO;\n                }\n";
                    } else if (!attr->isFixed()){
                        classFileOut << "                if (![self " << setMethodName(attrName) << ": val]) {\n                   return NO;\n                }\n";
                    } else {
                        // what to do, we get a fixed attribute which may be different from our own!
                        classFileOut << "                [" << variableName(attrName) << " release]; \n";
                        classFileOut << "                " << variableName(attrName) << " = val; // replace the default versioning number\n";
                        classFileOut << "                " << variableName(attr->name()) << "Present = YES;\n"; // issue 21
                        classFileOut << "                [" << variableName(attrName) << " retain]; \n";
                    }
                    classFileOut << "            }\n";
                }
            }
            classFileOut << "        }\n";
        }
        classFileOut << "        return YES;\n";
        classFileOut << "}\n\n";

        // xml generator
        // if attribute name and type are the same it means it was data
        classFileOut << "-(NSString *) XML {\n\n";
        classFileOut << "    NSMutableString *xml = [NSMutableString stringWithString:@\"<" << name << "\"];\n"; // append attributes

        // check for dataMembers before generating a useless variable
        bool hasDataMembers = false;
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            if (attr->isElement()) {
                hasDataMembers = true;
            }
        }
        if (hasDataMembers) {
            classFileOut << "    NSString *dataMember;\n"; // append attributes
        }

        // for attributes
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString type = localType(attr->type()); // convert to cpp types
            QString varName = variableName(attr->name());

            if (!attr->isElement()) {

                // non-qstring items (ints) may give problems, so convert them
                if (type == localType("xs:dateTime")) {
                    varName = "[self stringFromDate: " + variableName(attr->name()) + "]";
                } else if (type == localType("xs:integer")) {
                    varName = "[NSString stringWithFormat:@\"%d\", " + variableName(attr->name()) + "]";
                } else if (type == localType("xs:boolean")) {
                    varName = "(" + variableName(attr->name()) + "?@\"true\":@\"false\")";
                } else if (type != localType("xs:string")) {
                    QString format = "%f";
                    if (attr->hasDigits()) {
                        format = "%." +  QString::number(attr->digits()) + "f";
                    }
                    varName = "[NSString stringWithFormat:@\"" + format + "\", " + variableName(attr->name()) + "]";
                } else { // String, issue 19
                    varName = "[self encode: " + variableName(attr->name()) + "]";
                }

                // check if the attribute exist
                if (!attr->required() || obj->isMerged()) {
                    classFileOut << "    if ( [self has" << methodName(attr->name()) << "] ) {\n";
                    classFileOut << "        [xml appendString: @\" " << attr->name() << "=\\\"\"];\n";
                    classFileOut << "        [xml appendString: " << varName << "];\n";
                    classFileOut << "        [xml appendString: @\"\\\"\"];\n    }\n";
                } else {  // issue 21 check also for required attributes
                    classFileOut << "    if ( " << variableName(attr->name()) << "Present ) {\n";
                    classFileOut << "        [xml appendString: @\" " << attr->name() << "=\\\"\"];\n";
                    classFileOut << "        [xml appendString: " << varName << "];\n";
                    classFileOut << "        [xml appendString: @\"\\\"\"];\n";
                    classFileOut << "    } else { // required element is missing !\n";
                    classFileOut << "        [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: @\"" +
                    attr->name() +"\" forKey: @\"description\"]];\n";
                    classFileOut << "        return nil;\n";
                    classFileOut << "    }\n";
                }
            }
        }

        if (hasDataMembers) {
            classFileOut << "    [xml appendString:@\">\\n\"];\n"; // close the statement
            // for data members
            for(int j=0; j < attributes.size(); j++) {
                XSDAttribute *attr = attributes.at(j);
                QString attrType = className(attr->type());

                if (attr->isElement()) {
                    // check if the attribute exist
                    if (attr->isScalar() ) {
                        if (attr->hasMinOccurs()) { // issue 26
                            classFileOut << "    if ([" << variableName(attr->name()) << "s count] < " << attr->minOccurs() << ") {\n";
                            classFileOut << "        [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: @\"Not enough entries of " +
                            attr->name() +"\" forKey: @\"description\"]];\n";
                            classFileOut << "        return nil;\n";
                            classFileOut << "    }\n";
                        }
                        if (attr->hasMaxOccurs()) { // issue 26
                            classFileOut << "    if ([" << variableName(attr->name()) << "s count] > " << attr->maxOccurs() << ") {\n";
                            classFileOut << "        [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: @\"Too much entries of " +
                            attr->name() +"\" forKey: @\"description\"]];\n";
                            classFileOut << "        return nil;\n";
                            classFileOut << "    }\n";
                        }
                        classFileOut << "    for(int i=0; i < [" << variableName(attr->name()) << "s count]; i++ ) {\n";
                        classFileOut << "        " << attrType << " *attribute = [" << variableName(attr->name()) << "s objectAtIndex:i];\n";
                        classFileOut << "        dataMember = [attribute XML];\n";
                        classFileOut << "        if (dataMember != nil) {\n";
                        classFileOut << "            [xml appendString: dataMember];\n";
                        classFileOut << "        } else { \n";
                        classFileOut << "            [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: ";
                        classFileOut << "[NSDictionary dictionaryWithObject: @\"" + attr->name() +"\" forKey: @\"description\"]];\n";
                        classFileOut << "            return nil;\n";
                        classFileOut << "        }\n";
                        classFileOut << "    }\n";
                    } else if (!attr->required() || obj->isMerged()) {
                        classFileOut << "    if ( [self has" << methodName(attr->name()) << "] ) {\n";
                        if (attr->isSimpleElement()) {
                            // simple elements are already there in string format, simply embed them
                            classFileOut << "            [xml appendString: @\"<" << attr->name() << ">\"];\n";
                            classFileOut << "            [xml appendString: "<< variableName(attr->name()) <<"];\n";
                            classFileOut << "            [xml appendString: @\"</" << attr->name() << ">\"];\n";
                        } else {
                            classFileOut << "        dataMember = [" << variableName(attr->name()) << " XML];\n";
                            classFileOut << "        if (dataMember != nil) {\n";
                            classFileOut << "            [xml appendString: dataMember];\n";
                            classFileOut << "        } else { \n";
                            classFileOut << "            [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: ";
                            classFileOut << "[NSDictionary dictionaryWithObject: @\"" + attr->name() +"\" forKey: @\"description\"]];\n";
                            classFileOut << "            return nil;\n";
                            classFileOut << "        }\n";
                        }
                        classFileOut << "    }\n";
                    } else { // issue 21
                        classFileOut << "    if ( " << variableName(attr->name()) << "Present ) {\n";
                        classFileOut << "        dataMember = [" << variableName(attr->name()) << " XML];\n";
                        classFileOut << "        if (dataMember != nil) {\n";
                        classFileOut << "            [xml appendString: dataMember];\n";
                        classFileOut << "        } else { \n";
                        classFileOut << "            [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: ";
                        classFileOut << "[NSDictionary dictionaryWithObject: @\"" + attr->name() +"\" forKey: @\"description\"]];\n";
                        classFileOut << "            return nil;\n";
                        classFileOut << "        }\n";
                        classFileOut << "    } else { // required element is missing !\n";
                        classFileOut << "        [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: @\"" +
                        attr->name() +"\" forKey: @\"description\"]];\n";
                        classFileOut << "        return nil;\n";
                        classFileOut << "    }\n";
                    }
                }
            }

            // close up
            classFileOut << "    [xml appendString: @\"</" << name << ">\\n\"];\n"; // append attributes
        } else {
            classFileOut << "    [xml appendString:@\"/>\\n\"];\n"; // close the statement
        }
        classFileOut << "    return xml;\n";
        classFileOut << "}\n\n";

        // string encoder, issue 19
        classFileOut << "-(NSString *) encode: (NSString *) input {\n\n";
        classFileOut << "    NSMutableString *str = [[[NSMutableString alloc] initWithString: input] autorelease];\n\n";
        // issue 39
        classFileOut << "    [str replaceOccurrencesOfString: @\"&\" withString: @\"&amp;\" options: NSCaseInsensitiveSearch range: NSMakeRange(0, [str length])];\n";
        classFileOut << "    [str replaceOccurrencesOfString: @\"<\" withString: @\"&lt;\" options: NSCaseInsensitiveSearch range: NSMakeRange(0, [str length])];\n";
        classFileOut << "    [str replaceOccurrencesOfString: @\">\" withString: @\"&gt;\" options: NSCaseInsensitiveSearch range: NSMakeRange(0, [str length])];\n";
        classFileOut << "    [str replaceOccurrencesOfString: @\"\\\"\" withString: @\"&quot;\" options: NSCaseInsensitiveSearch range: NSMakeRange(0, [str length])];\n\n";
        classFileOut << "    return str;\n";
        classFileOut << "}\n\n";
        // end issue 19

        // string generator
        classFileOut << "-(NSString *) stringValue {\n\n";
        classFileOut << "    return [self stringValueWithLead:@\"\"];\n";
        classFileOut << "}\n\n";

        classFileOut << "-(NSString *) stringValueWithLead: (NSString *) lead {\n\n";
        classFileOut << "    NSMutableString *str = [[[NSMutableString alloc] init] autorelease];\n";
        classFileOut << "    [str setString: [lead stringByAppendingString:@\"" << name << "\\n\"]];\n"; // append attributes

        // for attributes
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString type = localType(attr->type()); // convert to cpp types
            QString varName = variableName(attr->name());

            if (!attr->isElement()) {

                // non-qstring items (ints) may give problems, so convert them
                if (type == localType("xs:dateTime")) {
                    varName = "[self stringFromDate: " + variableName(attr->name()) + "]";
                } else if (type == localType("xs:boolean")) {  // issue 64
                    varName = "(" + variableName(attr->name()) + "?@\"true\":@\"false\")";
                } else if (type == localType("xs:integer")) {
                    varName = "[NSString stringWithFormat:@\"%d\", " + variableName(attr->name()) + "]";
                } else if (type != localType("xs:string")) {
                    QString format = "%f";
                    if (attr->hasDigits()) {
                        format = "%." +  QString::number(attr->digits()) + "f";
                    }
                    varName = "[NSString stringWithFormat:@\"" + format + "\", " + variableName(attr->name()) + "]";
                }
                // check if the attribute exist
                if (!attr->required() || obj->isMerged()) {
                    classFileOut << "    if ( [self has" << methodName(attr->name()) << "] ) {\n";
                    classFileOut << "        [str appendString: [lead stringByAppendingString: @\" \"]];\n";
                    classFileOut << "        [str appendString: @\"" << attr->name() << " = \"];\n";
                    classFileOut << "        [str appendString: " << varName << "];\n";
                    classFileOut << "        [str appendString: @\"\\n\"];\n\n";
                    classFileOut << "    }\n";
                } else {
                    classFileOut << "    [str appendString: [lead stringByAppendingString: @\" \"]];\n";
                    classFileOut << "    [str appendString: @\"" << attr->name() << " = \"];\n";
                    classFileOut << "    [str appendString: " << varName << "];\n";
                    classFileOut << "    [str appendString: @\"\\n\"];\n\n";
                }
            }
        }

        // for data members (embedded attributes)
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = className(attr->type());

            if (attr->isElement()) {
                // check if the attribute exist
                if (attr->isScalar() ) {
                    classFileOut << "    for(int i=0; i < [" << variableName(attr->name()) << "s count]; i++ ) {\n";
                    classFileOut << "        " << attrType << " *attribute = [" << variableName(attr->name()) << "s objectAtIndex:i];\n";
                    classFileOut << "        [str appendString: [attribute stringValueWithLead: [lead stringByAppendingString: @\" \"]] ];\n    }\n";
                } else if (!attr->required() || obj->isMerged()) {
                    classFileOut << "    if ( [self has" << methodName(attr->name()) << "] ) {\n";
                    if (attr->isSimpleElement()) {
                        classFileOut << "        [str appendString: [lead stringByAppendingString: @\" \"]];\n";
                        classFileOut << "        [str appendString: @\"" << attr->name() << " = \"];\n";
                        classFileOut << "        [str appendString: " << variableName(attr->name()) << "];\n";
                        classFileOut << "        [str appendString: @\"\\n\"];\n\n";
                        classFileOut << "    }\n";
                    } else {
                        classFileOut << "        [str appendString:" << " [" << variableName(attr->name());
                        classFileOut << " stringValueWithLead: [lead stringByAppendingString: @\"    \"]] ];\n    }\n";
                    }
                } else {
                    classFileOut << "    [str appendString:" << " [" << variableName(attr->name()) << " stringValueWithLead: [lead stringByAppendingString: @\"    \"]] ];\n";
                }
            }
        }

        // close up
        classFileOut << "    return str;\n";
        classFileOut << "}\n\n";

        // create an array of properties for this object
        // not the embedded ones since there can be more than one of those
        classFileOut << "-(NSDictionary *) attributes {\n\n";
        classFileOut << "    NSMutableDictionary *attr = [[[NSMutableDictionary alloc] init] autorelease];\n";

        // for attributes
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString attrType = attr->type();
            QString myType = localType(attr->type()); // convert to cpp types
            QString varName = variableName(attr->name());

            if (!attr->isElement() && !attr->isSimpleElement()) {

                // non-qstring items (ints) may give problems, so convert them
                if (myType == localType("xs:dateTime")) {
                    varName = "[self stringFromDate: " + variableName(attr->name()) + "]";
                } else if (myType == localType("xs:integer")) {
                    varName = "[NSString stringWithFormat:@\"%d\", " + variableName(attr->name()) + "]";
                } else if (myType != localType("xs:string")) {
                    QString format = "%f";
                    if (attr->hasDigits()) {
                        format = "%." +  QString::number(attr->digits()) + "f";
                    }
                    varName = "[NSString stringWithFormat:@\"" + format + "\", " + variableName(attr->name()) + "]";
                }
                // check if the attribute exist
                if (!attr->required() || obj->isMerged()) {
                    classFileOut << "    if ( [self has" << methodName(attr->name()) << "] ) {\n";
                    classFileOut << "        [attr setObject: " << varName << " forKey: @\"" << attr->name() <<  "\"];\n";
                    classFileOut << "    }\n";
                } else {
                    classFileOut << "    [attr setObject: " << varName << " forKey: @\"" << attr->name() <<  "\"];\n";
                }
            }
        }

        // close up
        classFileOut << "\n    return attr;\n";
        classFileOut << "}\n\n";

        classFileOut << "\n@end\n\n";

        // round up
        classFileOut << "\n"; // make sure there is a newline at the end of the source

        // close and flush
        classFileOut.flush();
        classFile.close();
    }

    //-----------------------------------------------------------------------------------------------
    // now generate the parser
    //-----------------------------------------------------------------------------------------------

    // open the header file
    QString name = "Parser";

    QFile headerFile(m_outDir + "/" + fileBaseName(name) + ".h");
    if (!headerFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        std::cerr << QString("cannot create file: %1").arg(m_outDir + "/" +  fileBaseName(name) + ".h").toLatin1().data() << std::endl;
        std::exit(-1);
    }
    QTextStream headerFileOut(&headerFile);

    // and the parser file
    QFile classFile(m_outDir + "/" +  fileBaseName(name) + ".m");
    if (!classFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        std::cerr << QString("cannot create file: %1").arg(m_outDir + "/" +  fileBaseName(name) + ".m").toLatin1().data() << std::endl;
        std::exit(-1);
    }
    QTextStream classFileOut(&classFile);

    // generate the header
    headerFileOut << writeHeader( className(name) );
    //headerFileOut << "#ifndef __" << name.toUpper() << "_H__\n";
    //headerFileOut << "#define __" << name.toUpper() << "_H__\n\n";
    headerFileOut << "#import <Foundation/Foundation.h>\n";

    // include dependend files
    for(int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        headerFileOut << "#import \"" << fileBaseName(obj->name()) << ".h\"\n";
    }

    headerFileOut << "\n//-----------------------------------------------------------\n";
    headerFileOut << "//! \\brief       Class definition of " << className(name) << "\n";
    headerFileOut << "//!\n";

    // define the classa
    headerFileOut << "@interface " << className(name) << " : NSObject { \n"; // added suport for clang

    // vars section
    headerFileOut << "    NSMutableString *m_dataBuffer;\n";
    headerFileOut << "    NSMutableString *m_characterBuffer;\n";
    headerFileOut << "    NSMutableArray *m_objStack;\n";
    headerFileOut << "    NSMutableArray *m_closeTags;\n";
    headerFileOut << "}\n\n";

    // methods section
    headerFileOut << "//!Delegate method for NSXMLParser\n";
    headerFileOut << "//!\n";
    headerFileOut << "- (void)     parser:(NSXMLParser *)parser \n";
    headerFileOut << "    didStartElement:(NSString *)elementName\n";
    headerFileOut << "       namespaceURI:(NSString *)namespaceURI\n";
    headerFileOut << "      qualifiedName:(NSString *)qualifiedName\n";
    headerFileOut << "         attributes:(NSDictionary *)attributeDict;\n";
    headerFileOut << "//!Delegate method for NSXMLParser\n";
    headerFileOut << "//!\n";
    headerFileOut << "- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string;\n";
    headerFileOut << "//!Delegate method for NSXMLParser\n";
    headerFileOut << "//!\n";
    headerFileOut << "- (void)     parser:(NSXMLParser *)parser \n";
    headerFileOut << "      didEndElement:(NSString *)elementName\n";
    headerFileOut << "       namespaceURI:(NSString *)namespaceURI\n";
    headerFileOut << "      qualifiedName:(NSString *)qualifiedName;\n";
    headerFileOut << "- (BOOL) parseXMLString:(NSString *)data andBuffer: (BOOL) cont;\n";
    headerFileOut << "- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError;\n";

    // define the signales
    headerFileOut << "//!Published Notifications\n";
    headerFileOut << "//!\n";
    for(int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        if ((!obj->isEmbedded()) && (obj->name() != "Schema") ) {
            headerFileOut << "//    @\"" << "New" << className(obj->name()) << "\" with @\"Data\" = " << className(obj->name()) << "\n";
        }
    }
    headerFileOut << "//    @\"" << "ILParserError\" with @\"Error\" = NSError \n";
    headerFileOut << "//    @\"" << "ILValidationError\" with @\"Error\" = NString \n";

    // close the header
    headerFileOut << "\n@end\n\n";
    headerFileOut << "\n\n";

    // close and flush
    headerFileOut.flush();

    // The class file
    classFileOut << "\n#import \"" << fileBaseName(name) << ".h\"\n\n";
    classFileOut << "\n@implementation " << className(name) << "\n\n";

    // constructor
    classFileOut << "- (id) init {\n    self = [super init];\n    if (self != nil) {\n";
    classFileOut << "        m_dataBuffer = [[NSMutableString alloc] init];\n";
    classFileOut << "        m_characterBuffer = [[NSMutableString alloc] init];\n";
    classFileOut << "        m_objStack = [[NSMutableArray alloc] init];\n";
    //classFileOut << "        [self setDelegate: self]; // we are our own delegate\n"; // issue 35

    // iisue 40 start
    // create an array with all close tags
    classFileOut << "        m_closeTags = [[NSArray arrayWithObjects:";
    for(int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        if ((!obj->isEmbedded()) && (obj->name() != "Schema") ) {
            classFileOut << "@\"</" << obj->name() << ">\", ";
        }
    }
    classFileOut << "nil] retain];\n";
    // iisue 40 end

    classFileOut << "    }\n    return self;\n}\n\n";

    // destructor Issue 35
    classFileOut << "- (void) dealloc {\n";
    classFileOut << "        [m_dataBuffer release];\n";
    classFileOut << "        [m_objStack release];\n";
    classFileOut << "        [m_closeTags release];\n";
    classFileOut << "        [super dealloc];\n";
    classFileOut << "}\n\n";

    // maintain a buffer for character data
    classFileOut << "- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string {\n";
    classFileOut << "    [m_characterBuffer appendString: [string stringByTrimmingCharactersInSet: [NSCharacterSet whitespaceAndNewlineCharacterSet]]];\n";
    classFileOut << "}\n\n";

    // main parser routine
    classFileOut << "- (void)     parser:(NSXMLParser *)parser \n";
    classFileOut << "    didStartElement:(NSString *)elementName\n";
    classFileOut << "       namespaceURI:(NSString *)namespaceURI\n";
    classFileOut << "      qualifiedName:(NSString *)qualifiedName\n";
    classFileOut << "         attributes:(NSDictionary *)attributeDict {\n";

    // run through all objects
    bool first = true;

    classFileOut << "    // clear the character buffer\n";
    classFileOut << "    [m_characterBuffer setString: @\"\"];\n\n";

    classFileOut << "    // check all possible options\n";

    for(int i=0; i < m_objects.size(); i++) {

        XSDObject *obj = m_objects.at(i);

        // the scheme object will never be sent
        if (obj->name() == "Schema") {
            continue;
        }
        if (!first) {
            classFileOut << "    else if";
        } else {
            classFileOut << "    if";
            first = false;
        }
        // if the name matches my object
        classFileOut << " ([elementName isEqualToString: @\"" << obj->name() << "\"]) {\n";

        if (!obj->isSimpleElement()) { // a normal sub element
            // create a temp object
            classFileOut << "        " << className(obj->name()) << " *obj = [[" << className(obj->name()) << " alloc] init];\n";
            classFileOut << "        if (! [obj setAttributes: attributeDict] ) {\n";
            classFileOut << "            [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: elementName forKey: @\"description\"]];\n";
            classFileOut << "        };\n";
            // store in local object (or stack) and signal on end tag
            // this way we can set obj in objects
            classFileOut << "        [m_objStack addObject: obj ];\n";
            classFileOut << "        [obj release];\n";
        } else { // a simple type that is actually a data container
            classFileOut << "        // data will follow and end up in the m_characterBuffer\n";
        }
        classFileOut << "    }\n";
    }
    classFileOut << "}\n\n";

    // TODO check for attributes and messages we do not know and give an alert

    // the endTag routine
    classFileOut << "- (void)     parser:(NSXMLParser *)parser \n";
    classFileOut << "      didEndElement:(NSString *)elementName\n";
    classFileOut << "       namespaceURI:(NSString *)namespaceURI\n";
    classFileOut << "      qualifiedName:(NSString *)qualifiedName {\n";

    // run through all objects
    first = true;

    classFileOut << "    // check all possible options\n";

    for(int i=0; i < m_objects.size(); i++) {
        XSDObject *obj = m_objects.at(i);
        // the scheme object will never be sent
        if (obj->name() == "Schema") {
            continue;
        }
        if (!first) {
            classFileOut << "    else if";
        } else {
            classFileOut << "    if";
            first = false;
        }
        // if the name matches my object
        classFileOut << " ([elementName isEqualToString: @\"" << obj->name() << "\"]) {\n\n";

        if (!obj->isSimpleElement()) { // normal flow
            classFileOut << "        " << className(obj->name()) << " *obj = (" << className(obj->name()) << "*) [m_objStack lastObject];\n";
            classFileOut << "        [obj retain];\n";
            classFileOut << "        [m_objStack removeLastObject];\n";

            // for all objects that could accept such an object
            for(int i=0; i < m_objects.size(); i++) {
                XSDObject *parent = m_objects.at(i);

                for(int j=0; j < parent->attributes().size(); j++) {
                    XSDAttribute *attr = parent->attributes().at(j);
                    QString objType = attr->type();
                    //std::cout << QString("####: %1").arg(objType).toLatin1().data() << std::endl;
                    //std::cout << QString("##: %1").arg(className(obj->name())).toLatin1().data() << std::endl;

                    if (className(objType) == className(obj->name()) /*&& parent->isRootObject()*/) { // this object has an attribute of that type
                        classFileOut << "        if ( [[m_objStack lastObject] isKindOfClass: [" << className(parent->name()) << " class]]) {\n";
                        if (attr->isScalar() ) {
                            classFileOut << "                if (! [(("<< className(parent->name()) << "*) [m_objStack lastObject] ) add" << methodName(obj->name()) << ": obj ] ) {\n";
                            classFileOut << "                   [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: elementName forKey: @\"description\"]];\n";
                            classFileOut << "                };\n";
                        } else {
                            classFileOut << "                if (! [(("<< className(parent->name()) << "*) [m_objStack lastObject] ) " << setMethodName(obj->name()) << ": obj ] ) {\n";
                            classFileOut << "                   [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILValidationError\" object: self userInfo: [NSDictionary dictionaryWithObject: elementName forKey: @\"description\"]];\n";
                            classFileOut << "                };\n";
                        }
                        classFileOut << "        }\n"; // close if
                    }
                }
            }
            if ((!obj->isEmbedded())) { // only if this object is not embedded
                classFileOut << "        [[NSNotificationCenter defaultCenter] postNotificationName:@\"New" << className(obj->name()) << "\" object: self userInfo:[NSDictionary dictionaryWithObject: obj forKey: @\"Data\"]]; \n";
            }
            classFileOut << "        [obj release]; \n";

        } else { // closed element is not an element with properties but a data holder, this is stored at the parent level

            // for all objects that could accept such an object
            for(int i=0; i < m_objects.size(); i++) {
                XSDObject *parent = m_objects.at(i);

                for(int j=0; j < parent->attributes().size(); j++) {
                    XSDAttribute *attr = parent->attributes().at(j);
                    //std::cout << QString("####: %1").arg(attr->name()).toLatin1().data() << std::endl;
                    //std::cout << QString("##: %1").arg(obj->name()).toLatin1().data() << std::endl;

                    if (obj->name() == attr->name() ) { // this object has an datamember of that type
                        classFileOut << "        if ( [[m_objStack lastObject] isKindOfClass: [" << className(parent->name()) << " class]]) {\n";
                        classFileOut << "            "<< className(parent->name()) << "* parent = [m_objStack lastObject];\n\n";
                        classFileOut << "            // add the found characters to the parent\n";
                        classFileOut << "            [parent " << setMethodName(obj->name()) << ": m_characterBuffer];\n\n";
                        //classFileOut << "            if ([m_characterBuffer length] > 0) {\n";
                        //classFileOut << "               NSLog(@\"found  characters [%@] in [%@] these are added to parent\", m_characterBuffer, elementName);\n";
                        //classFileOut << "            }\n\n";
                        classFileOut << "            // clear the character buffer\n";
                        classFileOut << "            [m_characterBuffer setString: @\"\"];\n";
                        classFileOut << "        }\n"; // close if
                    }
                }
            }
        }
        classFileOut << "    }\n"; // close if
    }
    classFileOut << "}\n\n"; // close method

    // error handling
    classFileOut << "- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError {\n";
    classFileOut << "    NSLog(@\"ILParser.parseErrorOccured: %@\", parseError);\n";
    classFileOut <<"    [[NSNotificationCenter defaultCenter] postNotificationName:@\"ILParserError\" object: self userInfo:[NSDictionary dictionaryWithObject: parseError forKey: @\"Error\"]];\n";
    classFileOut << "}\n\n"; // close method

    // the parseXMLString routine
    classFileOut << "- (BOOL) parseXMLString:(NSString *)data andBuffer: (BOOL) cont {\n\n";

    // issue 40
    classFileOut << "     // create a seperate memory pool, so we can quickly deallocate temp objects generated by the parser\n";
    classFileOut << "     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\n";

    classFileOut << "	  // data may or may not be lead by xml definitions, but we need them before each message\n";
    classFileOut << "#if defined (__clang__)\n";
    classFileOut << "	  data = [data stringByReplacingString:@\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" withString:@\"\"];\n";
    classFileOut << "     data = [data stringByReplacingString:@\"<?xml version = \\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" withString:@\"\"];\n";
    classFileOut << "#else\n";
    classFileOut << "	  data = [data stringByReplacingOccurrencesOfString:@\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" withString:@\"\"];\n";
    classFileOut << "     data = [data stringByReplacingOccurrencesOfString:@\"<?xml version = \\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" withString:@\"\"];\n";
    classFileOut << "#endif\n";
    classFileOut << "     [m_dataBuffer appendString: data];\n\n";

    classFileOut << "     NSRange firstTagRange;\n";
    classFileOut << "     do {\n";
    classFileOut << "         // search if a message is in the buffer\n";
    classFileOut << "         firstTagRange = NSMakeRange(NSNotFound , 0);\n";
    classFileOut << "#if defined (__clang__)\n";
    classFileOut << "         for (int i=0; i < [m_closeTags count]; i++) {\n";
    classFileOut << "             NSString *tag = [m_closeTags objectAtIndex: i];\n";
    classFileOut << "#else\n";
    classFileOut << "         for (NSString *tag in m_closeTags) {\n";
    classFileOut << "#endif\n";
    classFileOut << "             NSRange rangeOfTag = [m_dataBuffer rangeOfString:tag];\n";
    classFileOut << "             if (rangeOfTag.location != NSNotFound) {\n";
    classFileOut << "                 if (firstTagRange.location != NSNotFound) {\n";
    classFileOut << "                     if (rangeOfTag.location < firstTagRange.location) {\n";
    classFileOut << "                         firstTagRange = rangeOfTag;\n";
    classFileOut << "                     }\n";
    classFileOut << "                 } else {\n";
    classFileOut << "                     firstTagRange = rangeOfTag;\n";
    classFileOut << "                 }\n";
    classFileOut << "             }\n";
    classFileOut << "         }\n";
    classFileOut << "         // process a message if found\n";
    classFileOut << "         if (firstTagRange.location != NSNotFound) {\n";
    classFileOut << "             NSRange firstMessageRange = NSMakeRange(0, firstTagRange.location + firstTagRange.length);\n";
    classFileOut << "             NSString *messages = [NSString stringWithFormat:@\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<xml>\\n%@\\n</xml>\", [m_dataBuffer substringWithRange:firstMessageRange]];\n";
    classFileOut << "             [m_dataBuffer deleteCharactersInRange:firstMessageRange];\n";
    classFileOut << "             NSXMLParser *tempParser = [[NSXMLParser alloc] initWithData:[messages dataUsingEncoding:NSUnicodeStringEncoding]];\n";
    classFileOut << "             [tempParser setDelegate:self];\n";
    classFileOut << "             [tempParser parse];\n";
    classFileOut << "             [tempParser release];\n";
    classFileOut << "         }        \n";
    classFileOut << "     } while (firstTagRange.location != NSNotFound);\n\n";

    classFileOut << "    if (!cont) {\n";
    classFileOut << "         [m_dataBuffer setString: @\"\"];\n";
    classFileOut << "     }\n\n";

    classFileOut << "     // free temp memory\n";
    classFileOut << "     [pool release];\n\n";
    classFileOut << "     return YES;\n";

    // issue 40
    classFileOut << "}\n\n"; // close method
    // round up
    classFileOut << "\n@end\n\n";
    classFileOut << "\n"; // make sure there is a newline at the end of the source

    // close and flush
    classFileOut.flush();
    classFile.close();
}

