/*
 *  codegenqt.cpp
 *
 *  schema2code is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  schema2code is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Created by Lukassen on 11/06/08.
 *  Copyright 2008
 *
 */

#include <cstdlib>

#include "codegenpb.h"

CodeGenPB::CodeGenPB()
: CodeGen()
{
        m_prefix = "";
}

void CodeGenPB::setObjects(QVector<XSDObject*>objects) {
    m_objects = objects;
}

void CodeGenPB::setOutputDir(QString outDir) {
    m_outDir = outDir;
}

QString CodeGenPB::localType(QString type) {
    if (type == "xs:string")
        return "string";
    else if (type == "xs:boolean")
        return "bool  ";
    else if (type == "xs:integer")
        return "int32 ";
    else if (type == "xs:hexBinary") 
        return "string";
    else if (type == "xs:dateTime")
        return "string";
    else if (type == "unknown") {
        std::cout << "WARNING unknown type found, defaulting to string" << std::endl;
        return "string";
    }
    else if (type == "xs:decimal") // float
        return "float ";
    else
        return m_prefix + type;
}

bool CodeGenPB::knownType(QString type) {
    if (type == "xs:string")
        return true;
    else if (type == "xs:boolean")
        return true;
    else if (type == "xs:hexBinary") 
        return true;
    else if (type == "xs:integer")
        return true;
    else if (type == "xs:dateTime")
        return true;
    else if (type == "unknown")
        return true;
    else if (type == "xs:decimal") // float
        return true;
    else
        return false;
}

QString CodeGenPB::fileBaseName(QString name) {
    return m_prefix + name;
}

QString CodeGenPB::className(QString name) {
    return m_prefix + methodName(name);
}

QString CodeGenPB::methodName(QString name) {
    return name.replace(0, 1, name.left(1).toUpper());
}

QString CodeGenPB::variableName(QString name) {

    if (name.mid(1,1).toUpper() == name.mid(1,1)) { // if second char is uppercase
        //return "m_" + name;
        return name;
    } else {
        //return "m_" + name.replace(0, 1, name.left(1).toLower());
        return name.replace(0, 1, name.left(1).toLower());
    }
}

QString CodeGenPB::writeHeader(QString fileName) {

    QString header;
    header.append( "/* \n" );
    header.append( " *  " + fileName + "\n" );
    header.append( " *\n" );
    header.append( " *  " + fileName + " is free software: you can redistribute it and/or modify\n" );
    header.append( " *  it under the terms of the GNU Lesser General Public License as published by\n" );
    header.append( " *  the Free Software Foundation, either version 3 of the License, or\n" );
    header.append( " *  (at your option) any later version.\n" );
    header.append( " *\n" );
    header.append( " *  Foobar is distributed in the hope that it will be useful,\n" );
    header.append( " *  but WITHOUT ANY WARRANTY ); without even the implied warranty of\n" );
    header.append( " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" );
    header.append( " *  GNU General Public License for more details.\n" );
    header.append( " *\n" );
    header.append( " **********************************************************************************\n" );
    header.append( " *  WARNING: THIS CODE WAS GENERATED DO NOT MODIFY, CHANGE THE XSD INSTEAD\n" );
    header.append( " *  Generated by schema2code on "+  QDateTime::currentDateTime().toString() + ".\n" );
    header.append( " **********************************************************************************\n" );
    header.append( " *  Copyright 2008\n" );
    header.append( " *\n" );
    header.append( " */\n\n" );

    return header;
}

void CodeGenPB::go() {

    // first analyse the objects if they are embedded objects
    // for all objects that could accept such an object
    for(int i=0; i < m_objects.size(); i++) {
        // for all objects
        XSDObject *obj1 = m_objects.at(i);

        // find if there is another object that refers to the obj
        for(int h=0; h < m_objects.size(); h++) {

            XSDObject *obj2 = m_objects.at(h);

            // refers means obj2 has an attribute of type obj1
            for(int j=0; j < obj2->attributes().size(); j++) {
                XSDAttribute *attr = obj2->attributes().at(j);
                QString objType = attr->type();

                if (objType == obj1->name()) {
                    obj1->setEmbedded();    // obj1 is embedded in obj2
                }
            }
        }
    }

    // open the proto filea
    QString baseName;
    if (m_prefix != "") {
        baseName = m_outDir + "/" + m_prefix + ".proto";
    } else { 
        baseName = m_outDir + "/interface.proto"; // must have prefix
    }
    QFile protoFile(baseName);
    if (!protoFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        std::cerr << QString("cannot create file: %1").arg(baseName).toLatin1().data() << std::endl;
        std::exit(-1);
    }
    QTextStream protoFileOut(&protoFile);

    // GPL header
    protoFileOut << writeHeader( baseName );

    for(int i=0; i < m_objects.size(); i++) {
        // get a class
        XSDObject *obj = m_objects.at(i);

        // get some vars we frequently use
        QString name = obj->name();
        QString upperName = name.toUpper();
        QVector<XSDAttribute*>attributes = obj->attributes();
        QMap<QString, QString>fixedValues = obj->fixedValues();

        // report
        std::cout << QString("creating class: %1").arg(className(name)).toLatin1().data() << std::endl;
    
        //-----------------------------------------------------------------------------------------------
        // generate the header
        //-----------------------------------------------------------------------------------------------

        // define the class
        protoFileOut << "\nmessage " << className(name) << " { \n";
        if (obj->hasBaseClass()) {
           protoFileOut << "\nextend " << className(obj->baseClass()) << " { \n";
        }
        
        // the tag counter
	int tag = 1;

        // variables  section
        for(int j=0; j < attributes.size(); j++) {
            XSDAttribute *attr = attributes.at(j);
            QString type = localType(attr->type()); // convert to cpp types
            // definition
            if (attr->isScalar()) { // there more then one
                protoFileOut << "    repeated " << type << " " << variableName(attr->name()) << " = " << tag++ << ";\n";
            } else if (!attr->required() || obj->isMerged()) {
                protoFileOut << "    optional " << type << " " << variableName(attr->name()) <<  " = " << tag++ << ";\n";
            } else {
                protoFileOut << "    required " << type << " " << variableName(attr->name()) << " = " << tag++ << ";\n";
            }
        }

        // and fixed values
        for(int j=0; j < fixedValues.size(); j++) {
            QString attrName = fixedValues.keys().at(j);
            protoFileOut << "    required string " << variableName(attrName) << " = " << tag++ << ";\n";
        }
        protoFileOut << "}\n";
        if (obj->hasBaseClass()) {
           protoFileOut << "}\n";
        }
    }

    // close and flush
    protoFileOut.flush();
    protoFile.close();
}

