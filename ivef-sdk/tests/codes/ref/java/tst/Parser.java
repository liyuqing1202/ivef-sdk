/* 
 *  Parser
 *
 *  Parser is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Foobar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY ); without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 **********************************************************************************
 *  WARNING: THIS CODE WAS GENERATED DO NOT MODIFY, CHANGE THE XSD INSTEAD
 *  Generated by schema2code on Mon Jan 14 21:29:48 2013.
 **********************************************************************************
 *  Copyright 2010
 *
 */

package tst;

import tst.ParserListener;
import java.util.*;
import java.util.regex.*;
import java.text.DateFormat;
import java.io.*;
import java.text.SimpleDateFormat;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import tst.MSG_Notification;
import tst.Message;
import tst.Event;

public class Parser extends DefaultHandler { 

    private String m_dataBuffer = new String();
    private String m_characterBuffer = new String();
    private ParserListener m_handler =  null;
    private Stack<Object> m_objStack = new Stack<Object>();
    private SAXParser m_parser; // init in constructor
    private Pattern m_closeTagsPattern; 

    public Parser(ParserListener handler) {

        m_handler = handler;

        // set the parser
        SAXParserFactory factory = SAXParserFactory.newInstance();
        m_closeTagsPattern = Pattern.compile( "</MSG_Notification>|</Argument>|</AreaName>");
        try { 
            m_parser = factory.newSAXParser();
        } catch(Exception e) {
            e.printStackTrace();
        }
}
     // Character buffer routine
     public void characters(char[] ch, int start, int length) throws SAXException {

         m_characterBuffer += ch;
     };

    public void startElement(String namespaceUri,
                             String localName,
                             String qName,
                             Attributes atts) throws SAXException {

         m_characterBuffer = ""; // reset buffer
    // check all possible options
    if (qName == "MSG_Notification") {
        MSG_Notification obj = new MSG_Notification();
        m_objStack.push( obj );
    }
    else if (qName == "Message") {
        Message obj = new Message();
        for (int i=0; i < atts.getLength(); i++) {
            String key = atts.getLocalName(i);
            String value = atts.getValue(i);

            if (key == "Argument") {
                String val = value;
                if (! obj.setArgument(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
            else if (key == "TimeStamp") {
                // if the time ends on a Z it is UTC, else localtime 
                Date val = new Date(); // starts since the epoch
                try { 
                    DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
                    if ( value.charAt(value.length()-1) == 'Z' )                        df.setTimeZone(TimeZone.getTimeZone("UTC"));                    val = df.parse( value );
                } catch(Exception e) {
                    try { // if there are no miliseconds they will not be sent
                       DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
                       if ( value.charAt(value.length()-1) == 'Z' )                          df.setTimeZone(TimeZone.getTimeZone("UTC"));                       val = df.parse( value );
                    } catch(Exception e2) {
                        e2.printStackTrace();
                    }
                }
                if (! obj.setTimeStamp(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
            else if (key == "Code") {
                int val = Integer.parseInt(value);
                if (! obj.setCode(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
            else if (key == "Version") {
                String val = value;
                if (! obj.setVersion(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
        }
        m_objStack.push( obj );
    }
    else if        // data will follow and end up in the m_characterBuffer
    }
    else if (qName == "Event") {
        Event obj = new Event();
        for (int i=0; i < atts.getLength(); i++) {
            String key = atts.getLocalName(i);
            String value = atts.getValue(i);

            if (key == "AreaName") {
                String val = value;
                if (! obj.setAreaName(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
            else if (key == "Name") {
                String val = value;
                if (! obj.setName(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
            else if (key == "Id") {
                int val = Integer.parseInt(value);
                if (! obj.setId(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
            else if (key == "Speed") {
                double val = Double.parseDouble(value.replace(",", "."));
                if (! obj.setSpeed(val) ) {
                   throw new SAXException("Validation Exception: " + key + " = " + value );
                }
            }
        }
        m_objStack.push( obj );
    }
    else if        // data will follow and end up in the m_characterBuffer
    }
}

    public void endElement(String namespaceUri,
                           String localName,
                           String qName) throws SAXException {

    // check all possible options
    if (qName == "MSG_Notification") {

        MSG_Notification obj = (MSG_Notification) ( m_objStack.pop() );
        if (m_handler != null) 
            m_handler.handleMSG_Notification( obj ); 
    }
    else if (qName == "Message") {

        Message obj = (Message) ( m_objStack.pop() );
        if ( m_objStack.peek().getClass() == new MSG_Notification().getClass() ) {
                if (! ((MSG_Notification) ( m_objStack.peek() ) ).addMessage( obj ) ) {
                   throw new SAXException("Validation Exception: " + qName);
                }
        }
    }
    else if (qName == "Argument") {

        Message *parent = (Message) ( m_objStack.top() );
        if (parent) {
             // add the found characters to the parent
             parent.addArgument(m_characterBuffer);
             // clear the character buffer
             m_characterBuffer = ;
        }
    }
    else if (qName == "Event") {

        Event obj = (Event) ( m_objStack.pop() );
        if ( m_objStack.peek().getClass() == new MSG_Notification().getClass() ) {
                if (! ((MSG_Notification) ( m_objStack.peek() ) ).addEvent( obj ) ) {
                   throw new SAXException("Validation Exception: " + qName);
                }
        }
    }
    else if (qName == "AreaName") {

        Event *parent = (Event) ( m_objStack.top() );
        if (parent) {
             // add the found characters to the parent
             parent.setAreaName(m_characterBuffer);
             // clear the character buffer
             m_characterBuffer = ;
        }
    }
}

    public boolean parseXMLString(String data, boolean cont) { 

     m_dataBuffer += data;


     // search the buffer for the nearest closetag
     int indexStart = 0, indexEnd = -1;

     // look for the pattern that defines a root element
     Matcher matcher = m_closeTagsPattern.matcher( m_dataBuffer );

     // parse the messages in the buffer one by one
     while ( matcher.find() ) {
         indexEnd = matcher.end();
         // isolate the messages
         String messages = m_dataBuffer.substring(indexStart, indexEnd);
         indexStart = indexEnd;
         // and parse
         try { 
             m_parser.parse(new InputSource(new StringReader(messages)), this);
         } catch(Exception e) {
             String errorMessage =
             "Error parsing " + messages + ": " + e;
             System.err.println(errorMessage);
             e.printStackTrace();
             return false;
         }
     }

     // check if we parsed messages
     if (indexEnd > -1) {
         // remove from buffer
         m_dataBuffer = m_dataBuffer.substring(indexEnd);
     }

     // check if we should flush the buffer
     if (!cont) {
         m_dataBuffer = "";
     }
     return true;
}


}
